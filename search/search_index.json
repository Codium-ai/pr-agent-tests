{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>CodiumAI PR-Agent is an open-source tool to help efficiently review and handle pull requests.</p> <ul> <li> <p>See the Installation Guide for instructions on installing and running the tool on different git platforms.</p> </li> <li> <p>See the Usage Guide for instructions on running the PR-Agent commands via different interfaces, including CLI, online usage, or by automatically triggering them when a new PR is opened.</p> </li> <li> <p>See the Tools Guide for a detailed description of the different tools.</p> </li> </ul>"},{"location":"#pr-agent-features","title":"PR-Agent Features","text":"<p>PR-Agent offers extensive pull request functionalities across various git providers.</p> GitHub Gitlab Bitbucket Azure DevOps TOOLS Review \u2705 \u2705 \u2705 \u2705 \u2b91 Incremental \u2705 \u2b91 SOC2 Compliance \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Ask \u2705 \u2705 \u2705 \u2705 Describe \u2705 \u2705 \u2705 \u2705 \u2b91 Inline file summary \ud83d\udc8e \u2705 \u2705 \u2705 Improve \u2705 \u2705 \u2705 \u2705 \u2b91 Extended \u2705 \u2705 \u2705 \u2705 Custom Prompt \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Reflect and Review \u2705 \u2705 \u2705 \u2705 Update CHANGELOG.md \u2705 \u2705 \u2705 \ufe0f Find Similar Issue \u2705 \ufe0f Add PR Documentation \ud83d\udc8e \u2705 \u2705 \u2705 Generate Custom Labels \ud83d\udc8e \u2705 \u2705 \u2705 Analyze PR Components \ud83d\udc8e \u2705 \u2705 \u2705 \ufe0f USAGE CLI \u2705 \u2705 \u2705 \u2705 App / webhook \u2705 \u2705 \u2705 \u2705 Actions \u2705 \ufe0f CORE PR compression \u2705 \u2705 \u2705 \u2705 Repo language prioritization \u2705 \u2705 \u2705 \u2705 Adaptive and token-aware file patch fitting \u2705 \u2705 \u2705 \u2705 Multiple models support \u2705 \u2705 \u2705 \u2705 Incremental PR review \u2705 Static code analysis \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Multiple configuration options \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 <p>\ud83d\udc8e marks a feature available only in PR-Agent Pro</p>"},{"location":"#example-results","title":"Example Results","text":""},{"location":"#describe","title":"/describe","text":""},{"location":"#review","title":"/review","text":""},{"location":"#improve","title":"/improve","text":""},{"location":"#generate_labels","title":"/generate_labels","text":""},{"location":"#how-it-works","title":"How it Works","text":"<p>The following diagram illustrates PR-Agent tools and their flow:</p> <p></p> <p>Check out the PR Compression strategy page for more details on how we convert a code diff to a manageable LLM prompt</p>"},{"location":"chrome-extension/","title":"Chrome Extension","text":""},{"location":"chrome-extension/#pr-agent-chrome-extension","title":"PR-Agent chrome extension","text":"<p>PR-Agent Chrome extension is a collection of tools that integrates seamlessly with your GitHub environment, aiming to enhance your PR-Agent usage experience, and providing additional features.</p>"},{"location":"chrome-extension/#features","title":"Features","text":""},{"location":"chrome-extension/#toolbar-extension","title":"Toolbar extension","text":"<p>With PR-Agent Chrome extension, it's easier than ever to interactively configure and experiment with the different tools and configuration options.</p> <p>After you found the setup that works for you, you can also easily export it as a persistent configuration file, and use it for automatic commands.</p> <p></p> <p></p>"},{"location":"chrome-extension/#pr-agent-filters","title":"PR-Agent filters","text":"<p>PR-Agent filters is a sidepanel option. that allows you to filter different message in the conversation tab.</p> <p>For example, you can choose to present only message from PR-Agent, or filter those messages, focusing only on user's comments.</p> <p></p> <p></p>"},{"location":"chrome-extension/#enhanced-code-suggestions","title":"Enhanced code suggestions","text":"<p>PR-Agent Chrome extension adds the following capabilities to code suggestions tool's comments:</p> <ul> <li>Auto-expand the table when you are viewing a code block, to avoid clipping.</li> <li>Adding a \"quote-and-reply\" button, that enables to address and comment on a specific suggestion (for example, asking the author to fix the issue)</li> </ul> <p></p> <p></p>"},{"location":"chrome-extension/#installation","title":"Installation","text":"<p>Go to the marketplace and install the extension: PR-Agent Chrome Extension</p>"},{"location":"chrome-extension/#pre-requisites","title":"Pre-requisites","text":"<p>The PR-Agent Chrome extension will work on any repo where you have previously installed PR-Agent.</p>"},{"location":"chrome-extension/#data-privacy-and-security","title":"Data privacy and security","text":"<p>The PR-Agent Chrome extension only modifies the visual appearance of a GitHub PR screen. It does not transmit any user's repo or pull request code. Code is only sent for processing when a user submits a GitHub comment that activates a PR-Agent tool, in accordance with the standard privacy policy of PR-Agent.</p>"},{"location":"core-abilities/","title":"Core Abilities","text":""},{"location":"core-abilities/#pr-compression-strategy","title":"PR Compression Strategy","text":"<p>There are two scenarios:</p> <ol> <li>The PR is small enough to fit in a single prompt (including system and user prompt)</li> <li>The PR is too large to fit in a single prompt (including system and user prompt)</li> </ol> <p>For both scenarios, we first use the following strategy</p>"},{"location":"core-abilities/#repo-language-prioritization-strategy","title":"Repo language prioritization strategy","text":"<p>We prioritize the languages of the repo based on the following criteria:</p> <ol> <li>Exclude binary files and non code files (e.g. images, pdfs, etc)</li> <li>Given the main languages used in the repo</li> <li>We sort the PR files by the most common languages in the repo (in descending order): </li> <li><code>[[file.py, file2.py],[file3.js, file4.jsx],[readme.md]]</code></li> </ol>"},{"location":"core-abilities/#small-pr","title":"Small PR","text":"<p>In this case, we can fit the entire PR in a single prompt: 1. Exclude binary files and non code files (e.g. images, pdfs, etc) 2. We Expand the surrounding context of each patch to 3 lines above and below the patch</p>"},{"location":"core-abilities/#large-pr","title":"Large PR","text":""},{"location":"core-abilities/#motivation","title":"Motivation","text":"<p>Pull Requests can be very long and contain a lot of information with varying degree of relevance to the pr-agent. We want to be able to pack as much information as possible in a single LMM prompt, while keeping the information relevant to the pr-agent.</p>"},{"location":"core-abilities/#compression-strategy","title":"Compression strategy","text":"<p>We prioritize additions over deletions:  - Combine all deleted files into a single list (<code>deleted files</code>)  - File patches are a list of hunks, remove all hunks of type deletion-only from the hunks in the file patch</p>"},{"location":"core-abilities/#adaptive-and-token-aware-file-patch-fitting","title":"Adaptive and token-aware file patch fitting","text":"<p>We use tiktoken to tokenize the patches after the modifications described above, and we use the following strategy to fit the patches into the prompt:</p> <ol> <li>Within each language we sort the files by the number of tokens in the file (in descending order):<ul> <li><code>[[file2.py, file.py],[file4.jsx, file3.js],[readme.md]]</code></li> </ul> </li> <li>Iterate through the patches in the order described above</li> <li>Add the patches to the prompt until the prompt reaches a certain buffer from the max token length</li> <li>If there are still patches left, add the remaining patches as a list called <code>other modified files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> <li>If we haven't reached the max token length, add the <code>deleted files</code> to the prompt until the prompt reaches the max token length (hard stop), skip the rest of the patches.</li> </ol>"},{"location":"core-abilities/#example","title":"Example","text":""},{"location":"core-abilities/#yaml-prompting","title":"YAML Prompting","text":"<p>TBD</p>"},{"location":"core-abilities/#static-code-analysis","title":"Static Code Analysis \ud83d\udc8e","text":"<p>TBD</p>"},{"location":"finetuning_benchmark/","title":"PR-Agent Code Fine-tuning Benchmark","text":"<p>On coding tasks, the gap between open-source models and top closed-source models such as GPT4 is significant.  In practice, open-source models are unsuitable for most real-world code tasks, and require further fine-tuning to produce acceptable results.</p> <p>PR-Agent fine-tuning benchmark aims to benchmark open-source models on their ability to be fine-tuned for a coding task. Specifically, we chose to fine-tune open-source models on the task of analyzing a pull request, and providing useful feedback and code suggestions.</p> <p>Here are the results:  </p> <p>Model performance:</p> Model name Model size [B] Better than gpt-4 rate, after fine-tuning [%] DeepSeek 34B-instruct 34 40.7 DeepSeek 34B-base 34 38.2 Phind-34b 34 38 Granite-34B 34 37.6 Codestral-22B-v0.1 22 32.7 QWEN-1.5-32B 32 29 CodeQwen1.5-7B 7 35.4 Granite-8b-code-instruct 8 34.2 CodeLlama-7b-hf 7 31.8 Gemma-7B 7 27.2 DeepSeek coder-7b-instruct 7 26.8 Llama-3-8B-Instruct 8 26.8 Mistral-7B-v0.1 7 16.1 <p></p> <p>Fine-tuning impact:</p> Model name Model size [B] Fine-tuned Better than gpt-4 rate [%] DeepSeek 34B-instruct 34 yes 40.7 DeepSeek 34B-instruct 34 no 3.6"},{"location":"finetuning_benchmark/#results-analysis","title":"Results analysis","text":"<ul> <li>Fine-tuning is a must - without fine-tuning, open-source models provide poor results on most real-world code tasks, which include complicated prompt and lengthy context. We clearly see that without fine-tuning, deepseek model was 96.4% of the time inferior to GPT-4, while after fine-tuning, it is better 40.7% of the time.</li> <li>Always start from a code-dedicated model \u2014 When fine-tuning, always start from a code-dedicated model, and not from a general-usage model. The gaps in downstream results are very big.</li> <li>Don't believe the hype \u2014newer models, or models from big-tech companies (Llama3, Gemma, Mistral), are not always better for fine-tuning.</li> <li>The best large model - For large 34B code-dedicated models, the gaps when doing proper fine-tuning are small. The current top model is DeepSeek 34B-instruct</li> <li>The best small model - For small 7B code-dedicated models, the gaps when fine-tuning are much larger. CodeQWEN 1.5-7B is by far the best model for fine-tuning.</li> <li>Base vs. instruct - For the top model (deepseek), we saw small advantage when starting from the instruct version. However, we recommend testing both versions on each specific task, as the base model is generally considered more suitable for fine-tuning.</li> </ul>"},{"location":"finetuning_benchmark/#the-dataset","title":"The dataset","text":""},{"location":"finetuning_benchmark/#training-dataset","title":"Training dataset","text":"<p>Our training dataset comprises 25,000 pull requests, aggregated from permissive license repos. For each pull request, we generated responses for the three main tools of PR-Agent: Describe, Review and Improve.</p> <p>On the raw data collected, we employed various automatic and manual cleaning techniques to ensure the outputs were of the highest quality, and suitable for instruct-tuning.</p> <p>Here are the prompts, and example outputs, used as input-output pairs to fine-tune the models:</p> Tool Prompt Example output Describe link link Review link link Improve link link"},{"location":"finetuning_benchmark/#evaluation-dataset","title":"Evaluation dataset","text":"<ul> <li>For each tool, we aggregated 100 additional examples to be used for evaluation. These examples were not used in the training dataset, and were manually selected to represent diverse real-world use-cases.</li> <li> <p>For each test example, we generated two responses: one from the fine-tuned model, and one from the best code model in the world, <code>gpt-4-turbo-2024-04-09</code>.</p> </li> <li> <p>We used a third LLM to judge which response better answers the prompt, and will likely be perceived by a human as better response. </p> </li> </ul> <p>We experimented with three model as judges: <code>gpt-4-turbo-2024-04-09</code>, <code>gpt-4o</code>, and <code>claude-3-opus-20240229</code>. All three produced similar results, with the same ranking order. This strengthens the validity of our testing protocol. The evaluation prompt can be found here</p> <p>Here is an example of a judge model feedback:</p> <pre><code>command: improve\nmodel1_score: 9,\nmodel2_score: 6,\nwhy: |\n  Response 1 is better because it provides more actionable and specific suggestions that directly \n  enhance the code's maintainability, performance, and best practices. For example, it suggests \n  using a variable for reusable widget instances and using named routes for navigation, which \n  are practical improvements. In contrast, Response 2 focuses more on general advice and less \n  actionable suggestions, such as changing variable names and adding comments, which are less \n  critical for immediate code improvement.\"\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#self-hosted-pr-agent","title":"Self-hosted PR-Agent","text":"<p>If you choose to host you own PR-Agent, you first need to acquire two tokens:</p> <ol> <li>An OpenAI key from here, with access to GPT-4 (or a key for other models, if you prefer).</li> <li>A GitHub\\GitLab\\BitBucket personal access token (classic), with the repo scope. [GitHub from here]</li> </ol> <p>There are several ways to use self-hosted PR-Agent:</p> <ul> <li>Locally</li> <li>GitHub</li> <li>GitLab</li> <li>BitBucket</li> <li>Azure DevOps</li> </ul>"},{"location":"installation/#pr-agent-pro","title":"PR-Agent Pro \ud83d\udc8e","text":"<p>PR-Agent Pro, an app for GitHub\\GitLab\\BitBucket hosted by CodiumAI, is also available.   With PR-Agent Pro Installation is as simple as signing up and adding the PR-Agent app to your relevant repo.  See here for more details.</p>"},{"location":"installation/azure/","title":"Azure DevOps","text":""},{"location":"installation/azure/#azure-devops-provider","title":"Azure DevOps provider","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml: <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre></p> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in expiration date, and will use the user identity for API calls.  Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml.  If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly,  or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml: <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre></p>"},{"location":"installation/azure/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To trigger from an Azure webhook, you need to manually add a webhook.  Use the \"Pull request created\" type to trigger a review, or \"Pull request commented on\" to trigger any supported comment with /  comment on the relevant PR. Note that for the \"Pull request commented on\" trigger, only API v2.0 is supported. <p>For webhook security, create a sporadic username/password pair and configure the webhook username and password on both the server and Azure DevOps webhook. These will be sent as basic Auth data by the webhook with each request: <pre><code>[azure_devops_server]\nwebhook_username = \"&lt;basic auth user&gt;\"\nwebhook_password = \"&lt;basic auth password&gt;\"\n</code></pre></p> <p> Ensure that the webhook endpoint is only accessible over HTTPS to mitigate the risk of credential interception when using basic authentication.</p>"},{"location":"installation/bitbucket/","title":"BitBucket","text":""},{"location":"installation/bitbucket/#run-as-a-bitbucket-pipeline","title":"Run as a Bitbucket Pipeline","text":"<p>You can use the Bitbucket Pipeline system to run PR-Agent on every pull request open or update.</p> <ol> <li>Add the following file in your repository bitbucket_pipelines.yml</li> </ol> <pre><code>pipelines:\n    pull-requests:\n      '**':\n        - step:\n            name: PR Agent Review\n            image: python:3.10\n            services:\n              - docker\n            script:\n              - docker run -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=https://bitbucket.org/$BITBUCKET_WORKSPACE/$BITBUCKET_REPO_SLUG/pull-requests/$BITBUCKET_PR_ID review\n</code></pre> <ol> <li>Add the following secure variables to your repository under Repository settings &gt; Pipelines &gt; Repository variables. OPENAI_API_KEY: <code>&lt;your key&gt;</code> BITBUCKET_BEARER_TOKEN: <code>&lt;your token&gt;</code></li> </ol> <p>You can get a Bitbucket token for your repository by following Repository Settings -&gt; Security -&gt; Access Tokens.</p> <p>Note that comments on a PR are not supported in Bitbucket Pipeline.</p>"},{"location":"installation/bitbucket/#run-using-codiumai-hosted-bitbucket-app","title":"Run using CodiumAI-hosted Bitbucket app","text":"<p>Please contact support@codium.ai or visit CodiumAI pricing page if you're interested in a hosted BitBucket app solution that provides full functionality including PR reviews and comment handling. It's based on the bitbucket_app.py implementation.</p>"},{"location":"installation/bitbucket/#bitbucket-server-and-data-center","title":"Bitbucket Server and Data Center","text":"<p>Login into your on-prem instance of Bitbucket with your service account username and password. Navigate to <code>Manage account</code>, <code>HTTP Access tokens</code>, <code>Create Token</code>. Generate the token and add it to .secret.toml under <code>bitbucket_server</code> section</p> <pre><code>[bitbucket_server]\nbearer_token = \"&lt;your key&gt;\"\n</code></pre>"},{"location":"installation/bitbucket/#run-it-as-cli","title":"Run it as CLI","text":"<p>Modify <code>configuration.toml</code>:</p> <pre><code>git_provider=\"bitbucket_server\"\n</code></pre> <p>and pass the Pull request URL: <pre><code>python cli.py --pr_url https://git.onpreminstanceofbitbucket.com/projects/PROJECT/repos/REPO/pull-requests/1 review\n</code></pre></p>"},{"location":"installation/bitbucket/#run-it-as-service","title":"Run it as service","text":"<p>To run pr-agent as webhook, build the docker image: <pre><code>docker build . -t codiumai/pr-agent:bitbucket_server_webhook --target bitbucket_server_webhook -f docker/Dockerfile\ndocker push codiumai/pr-agent:bitbucket_server_webhook  # Push to your Docker repository\n</code></pre></p> <p>Navigate to <code>Projects</code> or <code>Repositories</code>, <code>Settings</code>, <code>Webhooks</code>, <code>Create Webhook</code>. Fill the name and URL, Authentication None select the Pull Request Opened checkbox to receive that event as webhook.</p> <p>The URL should end with <code>/webhook</code>, for example: https://domain.com/webhook</p>"},{"location":"installation/github/","title":"GitHub","text":""},{"location":"installation/github/#run-as-a-github-action","title":"Run as a GitHub Action","text":"<p>You can use our pre-built Github Action Docker image to run PR-Agent as a Github Action.</p> <p>1) Add the following file to your repository under <code>.github/workflows/pr_agent.yml</code>:</p> <pre><code>on:\n  pull_request:\n    types: [opened, reopened, ready_for_review]\n  issue_comment:\njobs:\n  pr_agent_job:\n    if: ${{ github.event.sender.type != 'Bot' }}\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n      contents: write\n    name: Run pr agent on every pull request, respond to user comments\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: Codium-ai/pr-agent@main\n        env:\n          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>if you want to pin your action to a specific release (v2.0 for example) for stability reasons, use: <pre><code>...\n    steps:\n      - name: PR Agent action step\n        id: pragent\n        uses: Codium-ai/pr-agent@v2.0\n...\n</code></pre></p> <p>2) Add the following secret to your repository under <code>Settings &gt; Secrets and variables &gt; Actions &gt; New repository secret &gt; Add secret</code>:</p> <pre><code>Name = OPENAI_KEY\nSecret = &lt;your key&gt;\n</code></pre> <p>The GITHUB_TOKEN secret is automatically created by GitHub.</p> <p>3) Merge this change to your main branch. When you open your next PR, you should see a comment from <code>github-actions</code> bot with a review of your PR, and instructions on how to use the rest of the tools.</p> <p>4) You may configure PR-Agent by adding environment variables under the env section corresponding to any configurable property in the configuration file. Some examples: <pre><code>      env:\n        # ... previous environment values\n        OPENAI.ORG: \"&lt;Your organization name under your OpenAI account&gt;\"\n        PR_REVIEWER.REQUIRE_TESTS_REVIEW: \"false\" # Disable tests review\n        PR_CODE_SUGGESTIONS.NUM_CODE_SUGGESTIONS: 6 # Increase number of code suggestions\n</code></pre> See detailed usage instructions in the USAGE GUIDE</p>"},{"location":"installation/github/#run-as-a-github-app","title":"Run as a GitHub App","text":"<p>Allowing you to automate the review process on your private or public repositories.</p> <p>1) Create a GitHub App from the Github Developer Portal.</p> <ul> <li>Set the following permissions:<ul> <li>Pull requests: Read &amp; write</li> <li>Issue comment: Read &amp; write</li> <li>Metadata: Read-only</li> <li>Contents: Read-only</li> </ul> </li> <li>Set the following events:<ul> <li>Issue comment</li> <li>Pull request</li> <li>Push (if you need to enable triggering on PR update)</li> </ul> </li> </ul> <p>2) Generate a random secret for your app, and save it for later. For example, you can use:</p> <pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> <p>3) Acquire the following pieces of information from your app's settings page:</p> <ul> <li>App private key (click \"Generate a private key\" and save the file)</li> <li>App ID</li> </ul> <p>4) Clone this repository:</p> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <p>5) Copy the secrets template file and fill in the following:</p> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ul> <li>Your OpenAI key.</li> <li>Copy your app's private key to the private_key field.</li> <li>Copy your app's ID to the app_id field.</li> <li>Copy your app's webhook secret to the webhook_secret field.</li> <li> <p>Set deployment_type to 'app' in configuration.toml</p> <p>The .secrets.toml file is not copied to the Docker image by default, and is only used for local development. If you want to use the .secrets.toml file in your Docker image, you can add remove it from the .dockerignore file. In most production environments, you would inject the secrets file as environment variables or as mounted volumes. For example, in order to inject a secrets file as a volume in a Kubernetes environment you can update your pod spec to include the following, assuming you have a secret named <code>pr-agent-settings</code> with a key named <code>.secrets.toml</code>: <pre><code>       volumes:\n        - name: settings-volume\n          secret:\n            secretName: pr-agent-settings\n// ...\n       containers:\n// ...\n          volumeMounts:\n            - mountPath: /app/pr_agent/settings_prod\n              name: settings-volume\n</code></pre></p> <p>Another option is to set the secrets as environment variables in your deployment environment, for example <code>OPENAI.KEY</code> and <code>GITHUB.USER_TOKEN</code>.</p> </li> </ul> <p>6) Build a Docker image for the app and optionally push it to a Docker repository. We'll use Dockerhub as an example:</p> <pre><code>```\ndocker build . -t codiumai/pr-agent:github_app --target github_app -f docker/Dockerfile\ndocker push codiumai/pr-agent:github_app  # Push to your Docker repository\n```\n</code></pre> <ol> <li> <p>Host the app using a server, serverless function, or container environment. Alternatively, for development and    debugging, you may use tools like smee.io to forward webhooks to your local machine.     You can check Deploy as a Lambda Function</p> </li> <li> <p>Go back to your app's settings, and set the following:</p> </li> <li> <p>Webhook URL: The URL of your app's server or the URL of the smee.io channel.</p> </li> <li> <p>Webhook secret: The secret you generated earlier.</p> </li> <li> <p>Install the app by navigating to the \"Install App\" tab and selecting your desired repositories.</p> </li> </ol> <p>Note: When running PR-Agent from GitHub App, the default configuration file (configuration.toml) will be loaded. However, you can override the default tool parameters by uploading a local configuration file <code>.pr_agent.toml</code> For more information please check out the USAGE GUIDE</p>"},{"location":"installation/github/#deploy-as-a-lambda-function","title":"Deploy as a Lambda Function","text":"<p>Note that since AWS Lambda env vars cannot have \".\" in the name, you can replace each \".\" in an env variable with \"__\". For example: <code>GITHUB.WEBHOOK_SECRET</code> --&gt; <code>GITHUB__WEBHOOK_SECRET</code></p> <ol> <li>Follow steps 1-5 from here.</li> <li>Build a docker image that can be used as a lambda function     <code>shell     docker buildx build --platform=linux/amd64 . -t codiumai/pr-agent:serverless -f docker/Dockerfile.lambda</code></li> <li>Push image to ECR     <pre><code>docker tag codiumai/pr-agent:serverless &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:serverless\ndocker push &lt;AWS_ACCOUNT&gt;.dkr.ecr.&lt;AWS_REGION&gt;.amazonaws.com/codiumai/pr-agent:serverless\n</code></pre></li> <li>Create a lambda function that uses the uploaded image. Set the lambda timeout to be at least 3m.</li> <li>Configure the lambda function to have a Function URL.</li> <li>In the environment variables of the Lambda function, specify <code>AZURE_DEVOPS_CACHE_DIR</code> to a writable location such as /tmp. (see link)</li> <li>Go back to steps 8-9 of Method 5 with the function url as your Webhook URL.     The Webhook URL would look like <code>https://&lt;LAMBDA_FUNCTION_URL&gt;/api/v1/github_webhooks</code></li> </ol>"},{"location":"installation/github/#aws-codecommit-setup","title":"AWS CodeCommit Setup","text":"<p>Not all features have been added to CodeCommit yet.  As of right now, CodeCommit has been implemented to run the pr-agent CLI on the command line, using AWS credentials stored in environment variables.  (More features will be added in the future.)  The following is a set of instructions to have pr-agent do a review of your CodeCommit pull request from the command line:</p> <ol> <li>Create an IAM user that you will use to read CodeCommit pull requests and post comments<ul> <li>Note: That user should have CLI access only, not Console access</li> </ul> </li> <li>Add IAM permissions to that user, to allow access to CodeCommit (see IAM Role example below)</li> <li>Generate an Access Key for your IAM user</li> <li>Set the Access Key and Secret using environment variables (see Access Key example below)</li> <li>Set the <code>git_provider</code> value to <code>codecommit</code> in the <code>pr_agent/settings/configuration.toml</code> settings file</li> <li>Set the <code>PYTHONPATH</code> to include your <code>pr-agent</code> project directory<ul> <li>Option A: Add <code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent</code> to your <code>.env</code> file</li> <li>Option B: Set <code>PYTHONPATH</code> and run the CLI in one command, for example:<ul> <li><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent python pr_agent/cli.py [--ARGS]</code></li> </ul> </li> </ul> </li> </ol>"},{"location":"installation/github/#aws-codecommit-iam-role-example","title":"AWS CodeCommit IAM Role Example","text":"<p>Example IAM permissions to that user to allow access to CodeCommit:</p> <ul> <li>Note: The following is a working example of IAM permissions that has read access to the repositories and write access to allow posting comments</li> <li>Note: If you only want pr-agent to review your pull requests, you can tighten the IAM permissions further, however this IAM example will work, and allow the pr-agent to post comments to the PR</li> <li>Note: You may want to replace the <code>\"Resource\": \"*\"</code> with your list of repos, to limit access to only those repos</li> </ul> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"codecommit:BatchDescribe*\",\n                \"codecommit:BatchGet*\",\n                \"codecommit:Describe*\",\n                \"codecommit:EvaluatePullRequestApprovalRules\",\n                \"codecommit:Get*\",\n                \"codecommit:List*\",\n                \"codecommit:PostComment*\",\n                \"codecommit:PutCommentReaction\",\n                \"codecommit:UpdatePullRequestDescription\",\n                \"codecommit:UpdatePullRequestTitle\"\n            ],\n            \"Resource\": \"*\"\n        }\n    ]\n}\n</code></pre>"},{"location":"installation/github/#aws-codecommit-access-key-and-secret","title":"AWS CodeCommit Access Key and Secret","text":"<p>Example setting the Access Key and Secret using environment variables</p> <pre><code>export AWS_ACCESS_KEY_ID=\"XXXXXXXXXXXXXXXX\"\nexport AWS_SECRET_ACCESS_KEY=\"XXXXXXXXXXXXXXXX\"\nexport AWS_DEFAULT_REGION=\"us-east-1\"\n</code></pre>"},{"location":"installation/github/#aws-codecommit-cli-example","title":"AWS CodeCommit CLI Example","text":"<p>After you set up AWS CodeCommit using the instructions above, here is an example CLI run that tells pr-agent to review a given pull request. (Replace your specific PYTHONPATH and PR URL in the example)</p> <pre><code>PYTHONPATH=\"/PATH/TO/PROJECTS/pr-agent\" python pr_agent/cli.py \\\n  --pr_url https://us-east-1.console.aws.amazon.com/codesuite/codecommit/repositories/MY_REPO_NAME/pull-requests/321 \\\n  review\n</code></pre>"},{"location":"installation/gitlab/","title":"GitLab","text":""},{"location":"installation/gitlab/#run-a-gitlab-webhook-server","title":"Run a GitLab webhook server","text":"<ol> <li> <p>From the GitLab workspace or group, create an access token. Enable the \"api\" scope only.</p> </li> <li> <p>Generate a random secret for your app, and save it for later. For example, you can use:</p> </li> </ol> <p><pre><code>WEBHOOK_SECRET=$(python -c \"import secrets; print(secrets.token_hex(10))\")\n</code></pre> 3. Follow the instructions to build the Docker image, setup a secrets file and deploy on your own server from here steps 4-7.</p> <ol> <li> <p>In the secrets file, fill in the following:</p> <ul> <li>Your OpenAI key.</li> <li>In the [gitlab] section, fill in personal_access_token and shared_secret. The access token can be a personal access token, or a group or project access token.</li> <li>Set deployment_type to 'gitlab' in configuration.toml</li> </ul> </li> <li> <p>Create a webhook in GitLab. Set the URL to the URL of your app's server. Set the secret token to the generated secret from step 2. In the \"Trigger\" section, check the \u2018comments\u2019 and \u2018merge request events\u2019 boxes.</p> </li> <li> <p>Test your installation by opening a merge request or commenting or a merge request using one of CodiumAI's commands.</p> </li> </ol>"},{"location":"installation/locally/","title":"Locally","text":""},{"location":"installation/locally/#using-pip-package","title":"Using pip package","text":"<p>Install the package:</p> <pre><code>pip install pr-agent\n</code></pre> <p>Then run the relevant tool with the script below.  Make sure to fill in the required parameters (<code>user_token</code>, <code>openai_key</code>, <code>pr_url</code>, <code>command</code>):</p> <pre><code>from pr_agent import cli\nfrom pr_agent.config_loader import get_settings\n\ndef main():\n    # Fill in the following values\n    provider = \"github\" # GitHub provider\n    user_token = \"...\"  # GitHub user token\n    openai_key = \"...\"  # OpenAI key\n    pr_url = \"...\"      # PR URL, for example 'https://github.com/Codium-ai/pr-agent/pull/809'\n    command = \"/review\" # Command to run (e.g. '/review', '/describe', '/ask=\"What is the purpose of this PR?\"', ...)\n\n    # Setting the configurations\n    get_settings().set(\"CONFIG.git_provider\", provider)\n    get_settings().set(\"openai.key\", openai_key)\n    get_settings().set(\"github.user_token\", user_token)\n\n    # Run the command. Feedback will appear in GitHub PR comments\n    cli.run_command(pr_url, command)\n\n\nif __name__ == '__main__':\n    main()\n</code></pre>"},{"location":"installation/locally/#using-docker-image","title":"Using Docker image","text":"<p>A list of the relevant tools can be found in the tools guide.</p> <p>To invoke a tool (for example <code>review</code>), you can run directly from the Docker image. Here's how:</p> <ul> <li> <p>For GitHub: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e GITHUB.USER_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre></p> </li> <li> <p>For GitLab: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitlab -e GITLAB.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre></p> </li> </ul> <p>Note: If you have a dedicated GitLab instance, you need to specify the custom url as variable: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e CONFIG.GIT_PROVIDER=gitlab -e GITLAB.PERSONAL_ACCESS_TOKEN=&lt;your token&gt; -e GITLAB.URL=&lt;your gitlab instance url&gt; codiumai/pr-agent:latest --pr_url &lt;pr_url&gt; review\n</code></pre></p> <ul> <li>For BitBucket: <pre><code>docker run --rm -it -e CONFIG.GIT_PROVIDER=bitbucket -e OPENAI.KEY=$OPENAI_API_KEY -e BITBUCKET.BEARER_TOKEN=$BITBUCKET_BEARER_TOKEN codiumai/pr-agent:latest --pr_url=&lt;pr_url&gt; review\n</code></pre></li> </ul> <p>For other git providers, update CONFIG.GIT_PROVIDER accordingly, and check the <code>pr_agent/settings/.secrets_template.toml</code> file for the environment variables expected names and values.</p> <p>If you want to ensure you're running a specific version of the Docker image, consider using the image's digest: <pre><code>docker run --rm -it -e OPENAI.KEY=&lt;your key&gt; -e GITHUB.USER_TOKEN=&lt;your token&gt; codiumai/pr-agent@sha256:71b5ee15df59c745d352d84752d01561ba64b6d51327f97d46152f0c58a5f678 --pr_url &lt;pr_url&gt; review\n</code></pre></p> <p>Or you can run a specific released versions of pr-agent, for example: <pre><code>codiumai/pr-agent@v0.9\n</code></pre></p>"},{"location":"installation/locally/#run-from-source","title":"Run from source","text":"<ol> <li>Clone this repository:</li> </ol> <pre><code>git clone https://github.com/Codium-ai/pr-agent.git\n</code></pre> <ol> <li>Navigate to the <code>/pr-agent</code> folder and install the requirements in your favorite virtual environment:</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>Note: If you get an error related to Rust in the dependency installation then make sure Rust is installed and in your <code>PATH</code>, instructions: https://rustup.rs</p> <ol> <li>Copy the secrets template file and fill in your OpenAI key and your GitHub user token:</li> </ol> <pre><code>cp pr_agent/settings/.secrets_template.toml pr_agent/settings/.secrets.toml\nchmod 600 pr_agent/settings/.secrets.toml\n# Edit .secrets.toml file\n</code></pre> <ol> <li>Run the cli.py script:</li> </ol> <pre><code>python3 -m pr_agent.cli --pr_url &lt;pr_url&gt; review\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; ask &lt;your question&gt;\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; describe\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; improve\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; add_docs\npython3 -m pr_agent.cli --pr_url &lt;pr_url&gt; generate_labels\npython3 -m pr_agent.cli --issue_url &lt;issue_url&gt; similar_issue\n...\n</code></pre> <p>[Optional]\u00a0Add the pr_agent folder to your PYTHONPATH <pre><code>export PYTHONPATH=$PYTHONPATH:&lt;PATH to pr_agent folder&gt;\n</code></pre></p>"},{"location":"installation/pr_agent_pro/","title":"\ud83d\udc8e PR-Agent Pro","text":""},{"location":"installation/pr_agent_pro/#getting-started-with-pr-agent-pro","title":"Getting Started with PR-Agent Pro","text":"<p>PR-Agent Pro is a versatile application compatible with GitHub, GitLab, and BitBucket, hosted by CodiumAI. See here for more details about the benefits of using PR-Agent Pro.</p> <p>Interested parties can subscribe to PR-Agent Pro through the following link.  After subscribing, you are granted the ability to easily install the application across any of your repositories.</p> <p></p> <p>Each user who wants to use PR-Agent pro needs to buy a seat.  Initially, CodiumAI offers a two-week trial period at no cost, after which continued access requires each user to secure a personal seat. Once a user acquires a seat, they gain the flexibility to use PR-Agent Pro across any repository where it was enabled.</p> <p>Users without a purchased seat who interact with a repository featuring PR-Agent Pro are entitled to receive up to five complimentary feedbacks. Beyond this limit, PR-Agent Pro will cease to respond to their inquiries unless a seat is purchased.</p>"},{"location":"installation/pr_agent_pro/#install-pr-agent-pro-for-github-enterprise-server","title":"Install PR-Agent Pro for GitHub Enterprise Server","text":"<p>You can install PR-Agent Pro application on your GitHub Enterprise Server, and enjoy two weeks of free trial. After the trial period, to continue using PR-Agent Pro, you will need to contact us for an Enterprise license.</p>"},{"location":"installation/pr_agent_pro/#install-pr-agent-pro-for-gitlab-teams-enterprise","title":"Install PR-Agent Pro for GitLab (Teams &amp; Enterprise)","text":"<p>Since GitLab platform does not support apps, installing PR-Agent Pro for GitLab is a bit more involved, and requires the following steps:</p>"},{"location":"installation/pr_agent_pro/#step-1","title":"Step 1","text":"<p>Acquire a personal, project or group level access token. Enable the \u201capi\u201d scope in order to allow PR-Agent to read pull requests, comment and respond to requests.</p> <p></p> <p>Store the token in a safe place, you won\u2019t be able to access it again after it was generated.</p>"},{"location":"installation/pr_agent_pro/#step-2","title":"Step 2","text":"<p>Generate a shared secret and link it to the access token. Browse to https://register.gitlab.pr-agent.codium.ai. Fill in your generated GitLab token and your company or personal name in the appropriate fields and click \"Submit\".</p> <p>You should see \"Success!\" displayed above the Submit button, and a shared secret will be generated. Store it in a safe place, you won\u2019t be able to access it again after it was generated.</p>"},{"location":"installation/pr_agent_pro/#step-3","title":"Step 3","text":"<p>Install a webhook for your repository or groups, by clicking \u201cwebhooks\u201d on the settings menu. Click the \u201cAdd new webhook\u201d button.</p> <p></p> <p>In the webhook definition form, fill in the following fields: URL: https://pro.gitlab.pr-agent.codium.ai/webhook</p> <p>Secret token: Your CodiumAI key Trigger: Check the \u2018comments\u2019 and \u2018merge request events\u2019 boxes. Enable SSL verification: Check the box.</p> <p></p>"},{"location":"installation/pr_agent_pro/#step-4","title":"Step 4","text":"<p>You\u2019re all set!</p> <p>Open a new merge request or add a MR comment with one of PR-Agent\u2019s commands such as /review, /describe or /improve.</p>"},{"location":"overview/","title":"Overview","text":"<p>CodiumAI PR-Agent is an open-source tool to help efficiently review and handle pull requests.</p> <ul> <li> <p>See the Installation Guide for instructions on installing and running the tool on different git platforms.</p> </li> <li> <p>See the Usage Guide for instructions on running the PR-Agent commands via different interfaces, including CLI, online usage, or by automatically triggering them when a new PR is opened.</p> </li> <li> <p>See the Tools Guide for a detailed description of the different tools.</p> </li> </ul>"},{"location":"overview/#pr-agent-features","title":"PR-Agent Features","text":"<p>PR-Agent offers extensive pull request functionalities across various git providers.</p> GitHub Gitlab Bitbucket Azure DevOps TOOLS Review \u2705 \u2705 \u2705 \u2705 \u2b91 Incremental \u2705 \u2b91 SOC2 Compliance \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Ask \u2705 \u2705 \u2705 \u2705 Describe \u2705 \u2705 \u2705 \u2705 \u2b91 Inline file summary \ud83d\udc8e \u2705 \u2705 \u2705 Improve \u2705 \u2705 \u2705 \u2705 \u2b91 Extended \u2705 \u2705 \u2705 \u2705 Custom Prompt \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Reflect and Review \u2705 \u2705 \u2705 \u2705 Update CHANGELOG.md \u2705 \u2705 \u2705 \ufe0f Find Similar Issue \u2705 \ufe0f Add PR Documentation \ud83d\udc8e \u2705 \u2705 \u2705 Generate Custom Labels \ud83d\udc8e \u2705 \u2705 \u2705 Analyze PR Components \ud83d\udc8e \u2705 \u2705 \u2705 \ufe0f USAGE CLI \u2705 \u2705 \u2705 \u2705 App / webhook \u2705 \u2705 \u2705 \u2705 Actions \u2705 \ufe0f CORE PR compression \u2705 \u2705 \u2705 \u2705 Repo language prioritization \u2705 \u2705 \u2705 \u2705 Adaptive and token-aware file patch fitting \u2705 \u2705 \u2705 \u2705 Multiple models support \u2705 \u2705 \u2705 \u2705 Incremental PR review \u2705 Static code analysis \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 Multiple configuration options \ud83d\udc8e \u2705 \u2705 \u2705 \u2705 <p>\ud83d\udc8e marks a feature available only in PR-Agent Pro</p>"},{"location":"overview/#example-results","title":"Example Results","text":""},{"location":"overview/#describe","title":"/describe","text":""},{"location":"overview/#review","title":"/review","text":""},{"location":"overview/#improve","title":"/improve","text":""},{"location":"overview/#generate_labels","title":"/generate_labels","text":""},{"location":"overview/#how-it-works","title":"How it Works","text":"<p>The following diagram illustrates PR-Agent tools and their flow:</p> <p></p> <p>Check out the PR Compression strategy page for more details on how we convert a code diff to a manageable LLM prompt</p>"},{"location":"overview/data_privacy/","title":"Data Privacy","text":""},{"location":"overview/data_privacy/#self-hosted-pr-agent","title":"Self-hosted PR-Agent","text":"<ul> <li>If you host PR-Agent with your OpenAI API key, it is between you and OpenAI. You can read their API data privacy policy here: https://openai.com/enterprise-privacy</li> </ul>"},{"location":"overview/data_privacy/#pr-agent-pro","title":"PR-Agent Pro \ud83d\udc8e","text":"<ul> <li> <p>When using PR-Agent Pro \ud83d\udc8e, hosted by CodiumAI, we will not store any of your data, nor will we use it for training. You will also benefit from an OpenAI account with zero data retention.</p> </li> <li> <p>For certain clients, CodiumAI-hosted PR-Agent Pro will use CodiumAI\u2019s proprietary models. If this is the case, you will be notified.</p> </li> <li> <p>No passive collection of Code and Pull Requests\u2019 data \u2014 PR-Agent will be active only when you invoke it, and it will then extract and analyze only data relevant to the executed command and queried pull request.</p> </li> </ul>"},{"location":"overview/data_privacy/#pr-agent-chrome-extension","title":"PR-Agent Chrome extension","text":"<ul> <li>The PR-Agent Chrome extension serves solely to modify the visual appearance of a GitHub PR screen. It does not transmit any user's repo or pull request code. Code is only sent for processing when a user submits a GitHub comment that activates a PR-Agent tool, in accordance with the standard privacy policy of PR-Agent.</li> </ul>"},{"location":"overview/pr_agent_pro/","title":"\ud83d\udc8e PR-Agent Pro","text":"<p>PR-Agent Pro is a hosted version of PR-Agent, provided by CodiumAI. It is available for a monthly fee, and provides the following benefits:</p> <ol> <li> <p>Fully managed - We take care of everything for you - hosting, models, regular updates, and more. Installation is as simple as signing up and adding the PR-Agent app to your GitHub\\GitLab\\BitBucket repo.</p> </li> <li> <p>Improved privacy - No data will be stored or used to train models. PR-Agent Pro will employ zero data retention, and will use an OpenAI account with zero data retention.</p> </li> <li> <p>Improved support - PR-Agent Pro users will receive priority support, and will be able to request new features and capabilities.</p> </li> <li> <p>Additional tools</p> <ul> <li>Custom Prompt Suggestions</li> <li>Tests</li> <li>PR documentation</li> <li>Improve Component</li> <li>Similar code search</li> <li>CI feedback</li> <li>Analyze PR components</li> </ul> </li> <li> <p>Additional features</p> <ul> <li>Global and wiki configuration</li> <li>Interactive triggering</li> <li>Apply suggestions</li> <li>Advanced usage statistics</li> <li>Incorporating companies' best practices</li> <li>SOC2 compliance check</li> <li>Custom labels</li> <li>Inline file summary</li> <li>More ...</li> </ul> </li> <li> <p>Supporting self-hosted git servers - PR-Agent Pro can be installed on GitHub Enterprise Server, GitLab, and BitBucket. For more information, see the installation guide.</p> </li> </ol>"},{"location":"tools/","title":"Tools","text":"<p>Here is a list of PR-Agent tools, each with a dedicated page that explains how to use it:</p> Tool Description PR Description (<code>/describe</code>) Automatically generating PR description - title, type, summary, code walkthrough and labels PR Review (<code>/review</code>) Adjustable feedback about the PR, possible issues, security concerns, review effort and more Code Suggestions (<code>/improve</code>) Code suggestions for improving the PR Question Answering (<code>/ask ...</code>) Answering free-text questions about the PR, or on specific code lines Update Changelog (<code>/update_changelog</code>) Automatically updating the CHANGELOG.md file with the PR changes Find Similar Issue (<code>/similar_issue</code>) Automatically retrieves and presents similar issues Help (<code>/help</code>) Provides a list of all the available tools. Also enables to trigger them interactively (\ud83d\udc8e) \ud83d\udc8e Add Documentation (<code>/add_docs</code>) Generates documentation to methods/functions/classes that changed in the PR \ud83d\udc8e Generate Custom Labels (<code>/generate_labels</code>) Generates custom labels for the PR, based on specific guidelines defined by the user \ud83d\udc8e Analyze (<code>/analyze</code>) Identify code components that changed in the PR, and enables to interactively generate tests, docs, and code suggestions for each component \ud83d\udc8e Custom Prompt (<code>/custom_prompt</code>) Automatically generates custom suggestions for improving the PR code, based on specific guidelines defined by the user \ud83d\udc8e Generate Tests (<code>/test component_name</code>) Automatically generates unit tests for a selected component, based on the PR code changes \ud83d\udc8e Improve Component (<code>/improve_component component_name</code>) Generates code suggestions for a specific code component that changed in the PR \ud83d\udc8e CI Feedback (<code>/checks ci_job</code>) Automatically generates feedback and analysis for a failed CI job <p>Note that the tools marked with \ud83d\udc8e are available only for PR-Agent Pro users.</p>"},{"location":"tools/analyze/","title":"\ud83d\udc8e Analyze","text":""},{"location":"tools/analyze/#overview","title":"Overview","text":"<p>The <code>analyze</code> tool combines advanced static code analysis with LLM capabilities to provide a comprehensive analysis of the PR code changes.</p> <p>The tool scans the PR code changes, find the code components (methods, functions, classes) that changed, and enables to interactively generate tests, docs, code suggestions and similar code search for each component.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/analyze\n</code></pre></p>"},{"location":"tools/analyze/#example-usage","title":"Example usage","text":"<p>An example result:</p> <p></p> <p>Notes</p> <ul> <li>Language that are currently supported: Python, Java, C++, JavaScript, TypeScript, C#.</li> </ul>"},{"location":"tools/ask/","title":"Ask","text":""},{"location":"tools/ask/#overview","title":"Overview","text":"<p>The <code>ask</code> tool answers questions about the PR, based on the PR code changes. Make sure to be specific and clear in your questions. It can be invoked manually by commenting on any PR: <pre><code>/ask \"...\"\n</code></pre></p>"},{"location":"tools/ask/#example-usage","title":"Example usage","text":""},{"location":"tools/ask/#ask-lines","title":"Ask lines","text":"<p>You can run <code>/ask</code> on specific lines of code in the PR from the PR's diff view. The tool will answer questions based on the code changes in the selected lines. - Click on the '+' sign next to the line number to select the line. - To select multiple lines, click on the '+' sign of the first line and then hold and drag to select the rest of the lines.  - write <code>/ask \"...\"</code> in the comment box and press <code>Add single comment</code> button.</p> <p></p> <p>Note that the tool does not have \"memory\" of previous questions, and answers each question independently.</p>"},{"location":"tools/ask/#ask-on-images","title":"Ask on images","text":"<p>You can also ask questions about images that appear in the comment, where the entire PR code will be used as context.  The basic syntax is: <pre><code>/ask \"...\"\n\n[Image](https://real_link_to_image)\n</code></pre> where <code>https://real_link_to_image</code> is the direct link to the image.</p> <p>Note that GitHub has a built-in mechanism of pasting images in comments. However, pasted image does not provide a direct link. To get a direct link to an image, we recommend using the following scheme:</p> <p>1) First, post a comment that contains only the image:</p> <p></p> <p>2) Quote reply to that comment:</p> <p></p> <p>3) In the screen opened, type the question below the image:</p> <p> </p> <p>4) Post the comment, and receive the answer:</p> <p></p> <p>See a full video tutorial here</p>"},{"location":"tools/ci_feedback/","title":"\ud83d\udc8e CI Feedback","text":""},{"location":"tools/ci_feedback/#overview","title":"Overview","text":"<p>The CI feedback tool (<code>/checks)</code> automatically triggers when a PR has a failed check. The tool analyzes the failed checks and provides several feedbacks:</p> <ul> <li>Failed stage</li> <li>Failed test name</li> <li>Failure summary</li> <li>Relevant error logs</li> </ul>"},{"location":"tools/ci_feedback/#example-usage","title":"Example usage","text":"<p>\u2192 </p> <p>In addition to being automatically triggered, the tool can also be invoked manually by commenting on a PR: <pre><code>/checks \"https://github.com/{repo_name}/actions/runs/{run_number}/job/{job_number}\"\n</code></pre> where <code>{repo_name}</code> is the name of the repository, <code>{run_number}</code> is the run number of the failed check, and <code>{job_number}</code> is the job number of the failed check.</p>"},{"location":"tools/ci_feedback/#disabling-the-tool-from-running-automatically","title":"Disabling the tool from running automatically","text":"<p>If you wish to disable the tool from running automatically, you can do so by adding the following configuration to the configuration file: <pre><code>[checks]\nenable_auto_checks_feedback = false\n</code></pre></p>"},{"location":"tools/ci_feedback/#configuration-options","title":"Configuration options","text":"<ul> <li><code>enable_auto_checks_feedback</code> - if set to true, the tool will automatically provide feedback when a check is failed. Default is true.</li> <li><code>excluded_checks_list</code> - a list of checks to exclude from the feedback, for example: [\"check1\", \"check2\"]. Default is an empty list.</li> <li><code>persistent_comment</code> - if set to true, the tool will overwrite a previous checks comment with the new feedback. Default is true.</li> <li><code>enable_help_text=true</code> - if set to true, the tool will provide a help message when a user comments \"/checks\" on a PR. Default is true.</li> <li><code>final_update_message</code> - if <code>persistent_comment</code> is true and updating a previous checks message, the tool will also create a new message: \"Persistent checks updated to latest commit\". Default is true.</li> </ul>"},{"location":"tools/custom_labels/","title":"\ud83d\udc8e Custom Labels","text":""},{"location":"tools/custom_labels/#overview","title":"Overview","text":"<p>The <code>generate_labels</code> tool scans the PR code changes, and given a list of labels and their descriptions, it automatically suggests labels that match the PR code changes.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/generate_labels\n</code></pre></p>"},{"location":"tools/custom_labels/#example-usage","title":"Example usage","text":"<p>If we wish to add detect changes to SQL queries in a given PR, we can add the following custom label along with its description:</p> <p></p> <p>When running the <code>generate_labels</code> tool on a PR that includes changes in SQL queries, it will automatically suggest the custom label:</p> <p></p> <p>Note that in addition to the dedicated tool <code>generate_labels</code>, the custom labels will also be used by the <code>describe</code> tool.</p>"},{"location":"tools/custom_labels/#how-to-enable-custom-labels","title":"How to enable custom labels","text":"<p>There are 3 ways to enable custom labels:</p>"},{"location":"tools/custom_labels/#1-cli-local-configuration-file","title":"1. CLI (local configuration file)","text":"<p>When working from CLI, you need to apply the configuration changes to the custom_labels file:</p>"},{"location":"tools/custom_labels/#2-repo-configuration-file","title":"2. Repo configuration file","text":"<p>To enable custom labels, you need to apply the configuration changes to the local <code>.pr_agent.toml</code> file in you repository.</p>"},{"location":"tools/custom_labels/#3-handle-custom-labels-from-the-repos-labels-page","title":"3. Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>This feature is available only in PR-Agent Pro </p> <ul> <li>GitHub : <code>https://github.com/{owner}/{repo}/labels</code>, or click on the \"Labels\" tab in the issues or PRs page.</li> <li>GitLab : <code>https://gitlab.com/{owner}/{repo}/-/labels</code>, or click on \"Manage\" -&gt; \"Labels\" on the left menu.</li> </ul> <p>b. Add/edit the custom labels. It should be formatted as follows: * Label name: The name of the custom label. * Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>. The description should be comprehensive and detailed, indicating when to add the desired label.</p> <p></p> <p>c. Now the custom labels will be included in the <code>generate_labels</code> tool.</p> <p>This feature is supported in GitHub and GitLab.</p>"},{"location":"tools/custom_labels/#configuration-options","title":"Configuration options","text":"<ul> <li>Change <code>enable_custom_labels</code> to True: This will turn off the default labels and enable the custom labels provided in the custom_labels.toml file.</li> <li>Add the custom labels. It should be formatted as follows:</li> </ul> <pre><code>[config]\nenable_custom_labels=true\n\n[custom_labels.\"Custom Label Name\"]\ndescription = \"Description of when AI should suggest this label\"\n\n[custom_labels.\"Custom Label 2\"]\ndescription = \"Description of when AI should suggest this label 2\"\n</code></pre>"},{"location":"tools/custom_prompt/","title":"\ud83d\udc8e Custom Prompt","text":""},{"location":"tools/custom_prompt/#overview","title":"Overview","text":"<p>The <code>custom_prompt</code> tool scans the PR code changes, and automatically generates suggestions for improving the PR code. It shares similarities with the <code>improve</code> tool, but with one main difference: the <code>custom_prompt</code> tool will only propose suggestions that follow specific guidelines defined by the prompt in: <code>pr_custom_prompt.prompt</code> configuration.</p> <p>The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on a PR.</p> <p>When commenting, use the following template:</p> <pre><code>/custom_prompt --pr_custom_prompt.prompt=\"\nThe code suggestions should focus only on the following:\n- ...\n- ...\n\n\"\n</code></pre> <p>With a configuration file, use the following template:</p> <pre><code>[pr_custom_prompt]\nprompt=\"\"\"\\\nThe suggestions should focus only on the following:\n-...\n-...\n\n\"\"\"\n</code></pre> <p>Remember - with this tool, you are the prompter. Be specific, clear, and concise in the instructions. Specify relevant aspects that you want the model to focus on. \\ You might benefit from several trial-and-error iterations, until you get the correct prompt for your use case.</p>"},{"location":"tools/custom_prompt/#example-usage","title":"Example usage","text":"<p>Here is an example of a possible prompt, defined in the configuration file: <pre><code>[pr_custom_prompt]\nprompt=\"\"\"\\\nThe code suggestions should focus only on the following:\n- look for edge cases when implementing a new function\n- make sure every variable has a meaningful name\n- make sure the code is efficient\n\"\"\"\n</code></pre></p> <p>(The instructions above are just an example. We want to emphasize that the prompt should be specific and clear, and be tailored to the needs of your project)</p> <p>Results obtained with the prompt above:</p> <p></p>"},{"location":"tools/custom_prompt/#configuration-options","title":"Configuration options","text":"<p><code>prompt</code>: the prompt for the tool. It should be a multi-line string.</p> <p><code>num_code_suggestions</code>: number of code suggestions provided by the 'custom_prompt' tool. Default is 4.</p> <p><code>enable_help_text</code>: if set to true, the tool will display a help text in the comment. Default is true.</p>"},{"location":"tools/describe/","title":"Describe","text":""},{"location":"tools/describe/#overview","title":"Overview","text":"<p>The <code>describe</code> tool scans the PR code changes, and generates a description for the PR - title, type, summary, walkthrough and labels.</p> <p>The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR: <pre><code>/describe\n</code></pre></p>"},{"location":"tools/describe/#example-usage","title":"Example usage","text":""},{"location":"tools/describe/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/describe</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a description for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command: <pre><code>/describe --pr_description.some_config1=... --pr_description.some_config2=...\n</code></pre></p>"},{"location":"tools/describe/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>describe</code> automatically when a PR is opened, define in a configuration file: <pre><code>[github_app]\npr_commands = [\n    \"/describe\",\n    ...\n]\n\n[pr_description]\npublish_labels = ...\n...\n</code></pre></p> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_description]</code> section contains the configurations for the <code>describe</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/describe/#configuration-options","title":"Configuration options","text":"<p>Possible configurations</p> publish_labels If set to true, the tool will publish the labels to the PR. Default is true. publish_description_as_comment If set to true, the tool will publish the description as a comment to the PR. If false, it will overwrite the original description. Default is false. publish_description_as_comment_persistent If set to true and `publish_description_as_comment` is true, the tool will publish the description as a persistent comment to the PR. Default is true. add_original_user_description If set to true, the tool will add the original user description to the generated description. Default is true. generate_ai_title If set to true, the tool will also generate an AI title for the PR. Default is false. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\" enable_pr_type If set to false, it will not show the `PR type` as a text value in the description content. Default is true. final_update_message If set to true, it will add a comment message [`PR Description updated to latest commit...`](https://github.com/Codium-ai/pr-agent/pull/499#issuecomment-1837412176) after finishing calling `/describe`. Default is false. enable_semantic_files_types If set to true, \"Changes walkthrough\" section will be generated. Default is true. collapsible_file_list If set to true, the file list in the \"Changes walkthrough\" section will be collapsible. If set to \"adaptive\", the file list will be collapsible only if there are more than 8 files. Default is \"adaptive\". enable_large_pr_handling Pro feature. If set to true, in case of a large PR the tool will make several calls to the AI and combine them to be able to cover more files. Default is true. enable_help_text If set to true, the tool will display a help text in the comment. Default is false."},{"location":"tools/describe/#inline-file-summary","title":"Inline file summary \ud83d\udc8e","text":"<p>This feature enables you to copy the <code>changes walkthrough</code> table to the \"Files changed\" tab, so you can quickly understand the changes in each file while reviewing the code changes (diff view).</p> <p>To copy the <code>changes walkthrough</code> table to the \"Files changed\" tab, you can click on the checkbox that appears PR Description status message below the main PR Description:</p> <p></p> <p>If you prefer to have the file summaries appear in the \"Files changed\" tab on every PR, change the <code>pr_description.inline_file_summary</code> parameter in the configuration file, possible values are:</p> <ul> <li><code>'table'</code>: File changes walkthrough table will be displayed on the top of the \"Files changed\" tab, in addition to the \"Conversation\" tab.</li> </ul> <p></p> <ul> <li><code>true</code>: A collapsible file comment with changes title and a changes summary for each file in the PR.</li> </ul> <p></p> <ul> <li><code>false</code> (<code>default</code>): File changes walkthrough will be added only to the \"Conversation\" tab.</li> </ul> <p>Note: that this feature is currently available only for GitHub.</p>"},{"location":"tools/describe/#markers-template","title":"Markers template","text":"<p>To enable markers, set <code>pr_description.use_description_markers=true</code>. Markers enable to easily integrate user's content and auto-generated content, with a template-like mechanism.</p> <p>For example, if the PR original description was: <pre><code>User content...\n\n## PR Type:\npr_agent:type\n\n## PR Description:\npr_agent:summary\n\n## PR Walkthrough:\npr_agent:walkthrough\n</code></pre> The marker <code>pr_agent:type</code> will be replaced with the PR type, <code>pr_agent:summary</code> will be replaced with the PR summary, and <code>pr_agent:walkthrough</code> will be replaced with the PR walkthrough.</p> <p></p> <p>\u2192</p> <p></p> <p>Configuration params:</p> <ul> <li><code>use_description_markers</code>: if set to true, the tool will use markers template. It replaces every marker of the form <code>pr_agent:marker_name</code> with the relevant content. Default is false.</li> <li><code>include_generated_by_header</code>: if set to true, the tool will add a dedicated header: 'Generated by PR Agent at ...' to any automatic content. Default is true.</li> </ul>"},{"location":"tools/describe/#custom-labels","title":"Custom labels","text":"<p>The default labels of the describe tool are quite generic, since they are meant to be used in any repo: [<code>Bug fix</code>, <code>Tests</code>, <code>Enhancement</code>, <code>Documentation</code>, <code>Other</code>].</p> <p>You can define custom labels that are relevant for your repo and use cases. Custom labels can be defined in a configuration file, or directly in the repo's labels page.</p> <p>Make sure to provide proper title, and a detailed and well-phrased description for each label, so the tool will know when to suggest it. Each label description should be a conditional statement, that indicates if to add the label to the PR or not, according to the PR content.</p>"},{"location":"tools/describe/#handle-custom-labels-from-a-configuration-file","title":"Handle custom labels from a configuration file","text":"<p>Example for a custom labels configuration setup in a configuration file: <pre><code>[config]\nenable_custom_labels=true\n\n\n[custom_labels.\"sql_changes\"]\ndescription = \"Use when a PR contains changes to SQL queries\"\n\n[custom_labels.\"test\"]\ndescription = \"use when a PR primarily contains new tests\"\n\n...\n</code></pre></p>"},{"location":"tools/describe/#handle-custom-labels-from-the-repos-labels-page","title":"Handle custom labels from the Repo's labels page \ud83d\udc8e","text":"<p>You can also control the custom labels that will be suggested by the <code>describe</code> tool from the repo's labels page:</p> <ul> <li>GitHub : go to <code>https://github.com/{owner}/{repo}/labels</code> (or click on the \"Labels\" tab in the issues or PRs page)</li> <li>GitLab : go to <code>https://gitlab.com/{owner}/{repo}/-/labels</code> (or click on \"Manage\" -&gt; \"Labels\" on the left menu)</li> </ul> <p>Now add/edit the custom labels. they should be formatted as follows:</p> <ul> <li>Label name: The name of the custom label.</li> <li>Description: Start the description of with prefix <code>pr_agent:</code>, for example: <code>pr_agent: Description of when AI should suggest this label</code>.</li> </ul> <p>Examples for custom labels:</p> <ul> <li><code>Main topic:performance</code> -  pr_agent:The main topic of this PR is performance</li> <li><code>New endpoint</code> -  pr_agent:A new endpoint was added in this PR</li> <li><code>SQL query</code> -  pr_agent:A new SQL query was added in this PR</li> <li><code>Dockerfile changes</code> - pr_agent:The PR contains changes in the Dockerfile</li> <li>...</li> </ul> <p>The description should be comprehensive and detailed, indicating when to add the desired label. For example: </p>"},{"location":"tools/describe/#usage-tips","title":"Usage Tips","text":"<p>Automation</p> <ul> <li>When you first install PR-Agent app, the default mode for the describe tool is: <pre><code>pr_commands = [\"/describe\", ...]\n</code></pre> meaning the <code>describe</code> tool will run automatically on every PR, with the default configurations.</li> </ul> <ul> <li> <p>Markers are an alternative way to control the generated description, to give maximal control to the user. If you set:    <pre><code>pr_commands = [\"/describe --pr_description.use_description_markers=true\", ...]\n</code></pre>    the tool will replace every marker of the form <code>pr_agent:marker_name</code> in the PR description with the relevant content, where <code>marker_name</code> is one of the following:          * <code>type</code>: the PR type.          * <code>summary</code>: the PR summary.          * <code>walkthrough</code>: the PR walkthrough.</p> </li> <li> <p>Note that when markers are enabled, if the original PR description does not contain any markers, the tool will not alter the description at all.</p> </li> </ul>"},{"location":"tools/documentation/","title":"\ud83d\udc8e Documentation","text":""},{"location":"tools/documentation/#overview","title":"Overview","text":"<p>The <code>add_docs</code> tool scans the PR code changes, and automatically suggests documentation for any code components that changed in the PR (functions, classes, etc.).</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/add_docs\n</code></pre></p>"},{"location":"tools/documentation/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/add_docs</code> on any PR:</p> <p></p> <p>The tool will generate documentation for all the components that changed in the PR:</p> <p></p> <p></p> <p>You can state a name of a specific component in the PR to get documentation only for that component: <pre><code>/add_docs component_name\n</code></pre></p>"},{"location":"tools/documentation/#configuration-options","title":"Configuration options","text":"<ul> <li><code>docs_style</code>: The exact style of the documentation (for python docstring). you can choose between: <code>google</code>, <code>numpy</code>, <code>sphinx</code>, <code>restructuredtext</code>, <code>plain</code>. Default is <code>sphinx</code>.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\".</li> </ul> <p>Notes</p> <ul> <li>Language that are currently fully supported: Python, Java, C++, JavaScript, TypeScript, C#.</li> <li>This tool can also be triggered interactively by using the <code>analyze</code> tool.</li> </ul>"},{"location":"tools/help/","title":"Help","text":""},{"location":"tools/help/#overview","title":"Overview","text":"<p>The <code>help</code> tool provides a list of all the available tools and their descriptions. For PR-Agent Pro users, it also enables to trigger each tool by checking the relevant box.</p> <p>It can be invoked manually by commenting on any PR: <pre><code>/help\n</code></pre></p>"},{"location":"tools/help/#example-usage","title":"Example usage","text":"<p>An example result:</p> <p></p> <p>\u2192</p> <p></p>"},{"location":"tools/improve/","title":"Improve","text":""},{"location":"tools/improve/#overview","title":"Overview","text":"<p>The <code>improve</code> tool scans the PR code changes, and automatically generates suggestions for improving the PR code. The tool can be triggered automatically every time a new PR is opened, or it can be invoked manually by commenting on any PR: <pre><code>/improve\n</code></pre></p>"},{"location":"tools/improve/#example-usage","title":"Example usage","text":""},{"location":"tools/improve/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/improve</code> on any PR. The code suggestions by default are presented as a single comment:</p> <p></p> <p>To edit configurations related to the improve tool, use the following template: <pre><code>/improve --pr_code_suggestions.some_config1=... --pr_code_suggestions.some_config2=...\n</code></pre></p> <p>For example, you can choose to present the suggestions as commitable code comments, by running the following command: <pre><code>/improve --pr_code_suggestions.commitable_code_suggestions=true\n</code></pre></p> <p></p> <p>Note that a single comment has a significantly smaller PR footprint. We recommend this mode for most cases. Also note that collapsible are not supported in Bitbucket. Hence, the suggestions are presented there as code comments.</p>"},{"location":"tools/improve/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>improve</code> automatically when a PR is opened, define in a configuration file: <pre><code>[github_app]\npr_commands = [\n    \"/improve\",\n    ...\n]\n\n[pr_code_suggestions]\nnum_code_suggestions_per_chunk = ...\n...\n</code></pre></p> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_code_suggestions]</code> section contains the configurations for the <code>improve</code> tool you want to edit (if any)</li> </ul>"},{"location":"tools/improve/#usage-tips","title":"Usage Tips","text":""},{"location":"tools/improve/#self-review","title":"Self-review","text":"<p>If you set in a configuration file: <pre><code>[pr_code_suggestions]\ndemand_code_suggestions_self_review = true\n</code></pre> The <code>improve</code> tool will add a checkbox below the suggestions, prompting user to acknowledge that they have reviewed the suggestions. You can set the content of the checkbox text via: <pre><code>[pr_code_suggestions]\ncode_suggestions_self_review_text = \"... (your text here) ...\"\n</code></pre></p> <p></p> <p>\ud83d\udc8e In addition, by setting: <pre><code>[pr_code_suggestions]\napprove_pr_on_self_review = true\n</code></pre> the tool can automatically approve the PR when the user checks the self-review checkbox.</p> <p>Tip - demanding self-review from the PR author</p> <p>If you set the number of required reviewers for a PR to 2, this effectively means that the PR author must click the self-review checkbox before the PR can be merged (in addition to a human reviewer).</p> <p></p>"},{"location":"tools/improve/#extra-instructions-and-best-practices","title":"<code>Extra instructions</code> and <code>best practices</code>","text":""},{"location":"tools/improve/#extra-instructions","title":"Extra instructions","text":"<p>You can use the <code>extra_instructions</code> configuration option to give the AI model additional instructions for the <code>improve</code> tool. Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Specify relevant aspects that you want the model to focus on.</p> <p>Examples for possible instructions: <pre><code>[pr_code_suggestions]\nextra_instructions=\"\"\"\\\n(1) Answer in japanese\n(2) Don't suggest to add try-excpet block\n(3) Ignore changes in toml files\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points or numbers to make the instructions more readable.</p>"},{"location":"tools/improve/#best-practices","title":"Best practices \ud83d\udc8e","text":"<p>Another option to give additional guidance to the AI model is by creating a dedicated wiki page called <code>best_practices.md</code>.  This page can contain a list of best practices, coding standards, and guidelines that are specific to your repo/organization</p> <p>The AI model will use this page as a reference, and in case the PR code violates any of the guidelines, it will suggest improvements accordingly, with a dedicated label: <code>Organization best practice</code>. </p> <p>Example for a <code>best_practices.md</code> content can be found here (adapted from Google's pyguide). This file is only an example. Since it is used as a prompt for an AI model, we want to emphasize the following:</p> <ul> <li>It should be written in a clear and concise manner</li> <li>If needed, it should give short relevant code snippets as examples</li> <li>Up to 800 lines are allowed</li> </ul> <p>Example results:</p> <p></p> <p>Note that while the <code>extra instructions</code> are more related to the way the <code>improve</code> tool behaves, the <code>best_practices.md</code> file is a general guideline for the way code should be written in the repo. Using a combination of both can help the AI model to provide relevant and tailored suggestions.</p>"},{"location":"tools/improve/#configuration-options","title":"Configuration options","text":"<p>General options</p> num_code_suggestions Number of code suggestions provided by the 'improve' tool. Default is 4 for CLI, 0 for auto tools. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". rank_suggestions If set to true, the tool will rank the suggestions, based on importance. Default is false. commitable_code_suggestions If set to true, the tool will display the suggestions as commitable code comments. Default is false. persistent_comment If set to true, the improve comment will be persistent, meaning that every new improve request will edit the previous one. Default is false. self_reflect_on_suggestions If set to true, the improve tool will calculate an importance score for each suggestion [1-10], and sort the suggestion labels group based on this score. Default is true. suggestions_score_threshold  Any suggestion with importance score less than this threshold will be removed. Default is 0. Highly recommend not to set this value above 7-8, since above it may clip relevant suggestions that can be useful.  apply_suggestions_checkbox  Enable the checkbox to create a committable suggestion. Default is true. enable_help_text If set to true, the tool will display a help text in the comment. Default is true. <p>params for 'extended' mode</p> auto_extended_mode Enable extended mode automatically (no need for the --extended option). Default is true. num_code_suggestions_per_chunk Number of code suggestions provided by the 'improve' tool, per chunk. Default is 5. rank_extended_suggestions If set to true, the tool will rank the suggestions, based on importance. Default is true. max_number_of_calls Maximum number of chunks. Default is 5. final_clip_factor Factor to remove suggestions with low confidence. Default is 0.9."},{"location":"tools/improve/#a-note-on-code-suggestions-quality","title":"A note on code suggestions quality","text":"<ul> <li>While the current AI for code is getting better and better (GPT-4), it's not flawless. Not all the suggestions will be perfect, and a user should not accept all of them automatically. Critical reading and judgment are required.</li> <li>While mistakes of the AI are rare but can happen, a real benefit from the suggestions of the <code>improve</code> (and <code>review</code>) tool is to catch, with high probability, mistakes or bugs done by the PR author, when they happen. So, it's a good practice to spend the needed ~30-60 seconds to review the suggestions, even if not all of them are always relevant.</li> <li> <p>The hierarchical structure of the suggestions is designed to help the user to quickly understand them, and to decide which ones are relevant and which are not:</p> <ul> <li>Only if the <code>Category</code> header is relevant, the user should move to the summarized suggestion description</li> <li>Only if the summarized suggestion description is relevant, the user should click on the collapsible, to read the full suggestion description with a code preview example.</li> </ul> </li> </ul> <p>In addition, we recommend to use the <code>extra_instructions</code> field to guide the model to suggestions that are more relevant to the specific needs of the project.   Consider also trying the Custom Prompt Tool \ud83d\udc8e, that will only propose code suggestions that follow specific guidelines defined by user.</p>"},{"location":"tools/improve_component/","title":"\ud83d\udc8e Improve Component","text":""},{"location":"tools/improve_component/#overview","title":"Overview","text":"<p>The <code>improve_component</code> tool generates code suggestions for a specific code component that changed in the PR. it can be invoked manually by commenting on any PR: <pre><code>/improve_component component_name\n</code></pre></p> <p>To get a list of the components that changed in the PR and choose the relevant component interactively, use the <code>analyze</code> tool.</p>"},{"location":"tools/improve_component/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/improve_component</code> on any PR:</p> <p></p> <p>The tool will generate code suggestions for the selected component (if no component is stated, it will generate code suggestions for the largest component):</p> <p></p> <p>Notes - Language that are currently supported by the tool: Python, Java, C++, JavaScript, TypeScript, C#. - This tool can also be triggered interactively by using the <code>analyze</code> tool.</p>"},{"location":"tools/improve_component/#configuration-options","title":"Configuration options","text":"<ul> <li><code>num_code_suggestions</code>: number of code suggestions to provide. Default is 4</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on ...\".</li> <li><code>file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> </ul>"},{"location":"tools/review/","title":"Review","text":""},{"location":"tools/review/#overview","title":"Overview","text":"<p>The <code>review</code> tool scans the PR code changes, and generates a list of feedbacks about the PR, aiming to aid the reviewing process.  The tool can be triggered automatically every time a new PR is opened, or can be invoked manually by commenting on any PR: <pre><code>/review\n</code></pre></p> <p>Note that the main purpose of the <code>review</code> tool is to provide the PR reviewer with useful feedbacks and insights. The PR author, in contrast, may prefer to save time and focus on the output of the improve tool, which provides actionable code suggestions.</p>"},{"location":"tools/review/#example-usage","title":"Example usage","text":""},{"location":"tools/review/#manual-triggering","title":"Manual triggering","text":"<p>Invoke the tool manually by commenting <code>/review</code> on any PR:</p> <p></p> <p>After ~30 seconds, the tool will generate a review for the PR:</p> <p></p> <p>If you want to edit configurations, add the relevant ones to the command: <pre><code>/review --pr_reviewer.some_config1=... --pr_reviewer.some_config2=...\n</code></pre></p>"},{"location":"tools/review/#automatic-triggering","title":"Automatic triggering","text":"<p>To run the <code>review</code> automatically when a PR is opened, define in a configuration file: <pre><code>[github_app]\npr_commands = [\n    \"/review\",\n    ...\n]\n\n[pr_reviewer]\nnum_code_suggestions = ...\n...\n</code></pre></p> <ul> <li>The <code>pr_commands</code> lists commands that will be executed automatically when a PR is opened.</li> <li>The <code>[pr_reviewer]</code> section contains the configurations for the <code>review</code> tool you want to edit (if any).</li> </ul>"},{"location":"tools/review/#configuration-options","title":"Configuration options","text":"<p>General options</p> num_code_suggestions Number of code suggestions provided by the 'review' tool. For manual comments, default is 4. For PR-Agent app auto tools, default is 0, meaning no code suggestions will be provided by the review tool, unless you manually edit pr_commands. inline_code_comments If set to true, the tool will publish the code suggestions as comments on the code diff. Default is false. persistent_comment If set to true, the review comment will be persistent, meaning that every new review request will edit the previous one. Default is true. extra_instructions Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...\". enable_help_text If set to true, the tool will display a help text in the comment. Default is true. <p>Enable\\disable specific sub-sections</p> require_score_review If set to true, the tool will add a section that scores the PR. Default is false. require_tests_review If set to true, the tool will add a section that checks if the PR contains tests. Default is true. require_estimate_effort_to_review If set to true, the tool will add a section that estimates the effort needed to review the PR. Default is true. require_can_be_split_review If set to true, the tool will add a section that checks if the PR contains several themes, and can be split into smaller PRs. Default is false. require_security_review If set to true, the tool will add a section that checks if the PR contains a possible security or vulnerability issue. Default is true. <p>SOC2 ticket compliance \ud83d\udc8e</p> <p>This sub-tool checks if the PR description properly contains a ticket to a project management system (e.g., Jira, Asana, Trello, etc.), as required by SOC2 compliance. If not, it will add a label to the PR: \"Missing SOC2 ticket\".</p> require_soc2_ticket If set to true, the SOC2 ticket checker sub-tool will be enabled. Default is false. soc2_ticket_prompt The prompt for the SOC2 ticket review. Default is: `Does the PR description include a link to ticket in a project management system (e.g., Jira, Asana, Trello, etc.) ?`. Edit this field if your compliance requirements are different. <p>Adding PR labels</p> <p>You can enable\\disable the <code>review</code> tool to add specific labels to the PR:</p> enable_review_labels_security If set to true, the tool will publish a 'possible security issue' label if it detects a security issue. Default is true. enable_review_labels_effort If set to true, the tool will publish a 'Review effort [1-5]: x' label. Default is true. <p>Auto-approval</p> <p>If enabled, the <code>review</code> tool can approve a PR when a specific comment, <code>/review auto_approve</code>, is invoked.</p> enable_auto_approval If set to true, the tool will approve the PR when invoked with the 'auto_approve' command. Default is false. This flag can be changed only from configuration file. maximal_review_effort Maximal effort level for auto-approval. If the PR's estimated review effort is above this threshold, the auto-approval will not run. Default is 5."},{"location":"tools/review/#usage-tips","title":"Usage Tips","text":"<p>General guidelines</p> <p>The <code>review</code> tool provides a collection of configurable feedbacks about a PR. It is recommended to review the Configuration options section, and choose the relevant options for your use case.</p> <p>Some of the features that are disabled by default are quite useful, and should be considered for enabling. For example:  <code>require_score_review</code>, <code>require_soc2_ticket</code>, and more.</p> <p>On the other hand, if you find one of the enabled features to be irrelevant for your use case, disable it. No default configuration can fit all use cases.</p> <p>Automation</p> <p>When you first install PR-Agent app, the default mode for the <code>review</code> tool is: <pre><code>pr_commands = [\"/review --pr_reviewer.num_code_suggestions=0\", ...]\n</code></pre> Meaning the <code>review</code> tool will run automatically on every PR, without providing code suggestions. Edit this field to enable/disable the tool, or to change the used configurations.</p> <p>Possible labels from the review tool</p> <p>The <code>review</code> tool can auto-generate two specific types of labels for a PR:</p> <ul> <li>a <code>possible security issue</code> label that detects if a possible security issue exists in the PR code (<code>enable_review_labels_security</code> flag)</li> <li>a <code>Review effort [1-5]: x</code> label, where x is the estimated effort to review the PR (<code>enable_review_labels_effort</code> flag)</li> </ul> <p>Both modes are useful, and we recommended to enable them.</p> <p>Extra instructions</p> <p>Extra instructions are important. The <code>review</code> tool can be configured with extra instructions, which can be used to guide the model to a feedback tailored to the needs of your project.</p> <p>Be specific, clear, and concise in the instructions. With extra instructions, you are the prompter. Specify the relevant sub-tool, and the relevant aspects of the PR that you want to emphasize.</p> <p>Examples for extra instructions: <pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\nIn the code feedback section, emphasize the following:\n- Does the code logic cover relevant edge cases?\n- Is the code logic clear and easy to understand?\n- Is the code logic efficient?\n...\n\"\"\"\n</code></pre> Use triple quotes to write multi-line instructions. Use bullet points to make the instructions more readable.</p> <p>Auto-approval</p> <p>PR-Agent can approve a PR when a specific comment is invoked.</p> <p>To ensure safety, the auto-approval feature is disabled by default. To enable auto-approval, you need to actively set in a pre-defined configuration file the following: <pre><code>[pr_reviewer]\nenable_auto_approval = true\n</code></pre> (this specific flag cannot be set with a command line argument, only in the configuration file, committed to the repository)</p> <p>After enabling, by commenting on a PR: <pre><code>/review auto_approve\n</code></pre> PR-Agent will automatically approve the PR, and add a comment with the approval.</p> <p>You can also enable auto-approval only if the PR meets certain requirements, such as that the <code>estimated_review_effort</code> label is equal or below a certain threshold, by adjusting the flag: <pre><code>[pr_reviewer]\nmaximal_review_effort = 5\n</code></pre></p>"},{"location":"tools/similar_code/","title":"\ud83d\udc8e Similar Code","text":""},{"location":"tools/similar_code/#overview","title":"Overview","text":"<p>The similar code tool retrieves the most similar code components from inside the organization's codebase, or from open-source code.</p> <p>For example:</p> <p><code>Global Search</code> for a method called <code>chat_completion</code>:</p> <p></p> <p>PR-Agent will examine the code component and will extract the most relevant keywords to search for similar code:</p> <ul> <li><code>extracted keywords</code>: the keywords that were extracted from the code by PR-Agent. the link will open a search page with the extracted keywords, to allow the user to modify the search if needed.</li> <li><code>search context</code>: the context in which the search will be performed, organization's codebase or open-source code (Global).</li> <li><code>similar code</code>: the most similar code components found. the link will open the code component in the relevant file.</li> <li><code>relevant repositories</code>: the open-source repositories in which that are relevant to the searched code component and it's keywords.</li> </ul> <p>Search result link example:</p> <p></p> <p><code>Organization Search</code>:</p> <p></p>"},{"location":"tools/similar_code/#how-to-use","title":"How to use","text":""},{"location":"tools/similar_code/#manually","title":"Manually","text":"<p>To invoke the <code>similar code</code> tool manually, comment on the PR: <pre><code>/find_similar_component COMPONENT_NAME\n</code></pre> Where <code>COMPONENT_NAME</code> should be the name of a code component in the PR (class, method, function).</p> <p>If there is a name ambiguity, there are two configurations that will help the tool to find the correct component:</p> <ul> <li><code>--pr_find_similar_component.file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>--pr_find_similar_component.class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> </ul> <p>example: <pre><code>/find_similar_component COMPONENT_NAME --pr_find_similar_component.file=FILE_NAME\n</code></pre></p>"},{"location":"tools/similar_code/#automatically-via-analyze-table","title":"Automatically (via Analyze table)","text":"<p>It can be invoked automatically from the analyze table, can be accessed by: <pre><code>/analyze\n</code></pre> Choose the components you want to find similar code for, and click on the <code>similar</code> checkbox. </p> <p>If you are looking to search for similar code in the organization's codebase, you can click on the <code>Organization</code> checkbox, and it will invoke a new search command just for the organization's codebase. </p> <p></p>"},{"location":"tools/similar_code/#configuration-options","title":"Configuration options","text":"<ul> <li><code>search_from_org</code>: if set to true, the tool will search for similar code in the organization's codebase. Default is false.</li> <li><code>number_of_keywords</code>: number of keywords to use for the search. Default is 5.</li> <li><code>number_of_results</code>: the maximum number of results to present. Default is 5.</li> </ul>"},{"location":"tools/similar_issues/","title":"Similar Issues","text":""},{"location":"tools/similar_issues/#overview","title":"Overview","text":"<p>The similar issue tool retrieves the most similar issues to the current issue. It can be invoked manually by commenting on any PR: <pre><code>/similar_issue\n</code></pre></p>"},{"location":"tools/similar_issues/#example-usage","title":"Example usage","text":"<p>Note that to perform retrieval, the <code>similar_issue</code> tool indexes all the repo previous issues (once).</p> <p>Select VectorDBs by changing <code>pr_similar_issue</code> parameter in <code>configuration.toml</code> file </p> <p>2 VectorDBs are available to switch in 1. LanceDB 2. Pinecone</p> <p>To enable usage of the 'similar issue' tool for Pinecone, you need to set the following keys in <code>.secrets.toml</code> (or in the relevant environment variables):</p> <p><pre><code>[pinecone]\napi_key = \"...\"\nenvironment = \"...\"\n</code></pre> These parameters can be obtained by registering to Pinecone.</p>"},{"location":"tools/similar_issues/#how-to-use","title":"How to use","text":"<ul> <li> <p>To invoke the 'similar issue' tool from CLI, run: <code>python3 cli.py --issue_url=... similar_issue</code></p> </li> <li> <p>To invoke the 'similar' issue tool via online usage, comment on a PR: <code>/similar_issue</code></p> </li> <li> <p>You can also enable the 'similar issue' tool to run automatically when a new issue is opened, by adding it to the pr_commands list in the github_app section</p> </li> </ul>"},{"location":"tools/test/","title":"\ud83d\udc8e Test","text":""},{"location":"tools/test/#overview","title":"Overview","text":"<p>By combining LLM abilities with static code analysis, the <code>test</code> tool  generate tests for a selected component, based on the PR code changes. It can be invoked manually by commenting on any PR: <pre><code>/test component_name\n</code></pre> where 'component_name' is the name of a specific component in the PR. To get a list of the components that changed in the PR and choose the relevant component interactively, use the <code>analyze</code> tool.</p>"},{"location":"tools/test/#example-usage","title":"Example usage","text":"<p>Invoke the tool manually by commenting <code>/test</code> on any PR:</p> <p></p> <p>The tool will generate tests for the selected component (if no component is stated, it will generate tests for largest component):</p> <p></p> <p></p> <p>(Example taken from here):</p> <p>Notes - Language that are currently supported by the tool: Python, Java, C++, JavaScript, TypeScript, C#. - This tool can also be triggered interactively by using the <code>analyze</code> tool.</p>"},{"location":"tools/test/#configuration-options","title":"Configuration options","text":"<ul> <li><code>num_tests</code>: number of tests to generate. Default is 3.</li> <li><code>testing_framework</code>: the testing framework to use. If not set, for Python it will use <code>pytest</code>, for Java it will use <code>JUnit</code>, for C++ it will use <code>Catch2</code>, and for JavaScript and TypeScript it will use <code>jest</code>.</li> <li><code>avoid_mocks</code>: if set to true, the tool will try to avoid using mocks in the generated tests. Note that even if this option is set to true, the tool might still use mocks if it cannot generate a test without them. Default is true.</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"use the following mock injection scheme: ...\".</li> <li><code>file</code>: in case there are several components with the same name, you can specify the relevant file.</li> <li><code>class_name</code>: in case there are several methods with the same name in the same file, you can specify the relevant class name.</li> <li><code>enable_help_text</code>: if set to true, the tool will add a help text to the PR comment. Default is true.</li> </ul>"},{"location":"tools/update_changelog/","title":"Update Changelog","text":""},{"location":"tools/update_changelog/#overview","title":"Overview","text":"<p>The <code>update_changelog</code> tool automatically updates the CHANGELOG.md file with the PR changes. It can be invoked manually by commenting on any PR: <pre><code>/update_changelog\n</code></pre></p>"},{"location":"tools/update_changelog/#example-usage","title":"Example usage","text":""},{"location":"tools/update_changelog/#configuration-options","title":"Configuration options","text":"<p>Under the section <code>pr_update_changelog</code>, the configuration file contains options to customize the 'update changelog' tool:</p> <ul> <li><code>push_changelog_changes</code>: whether to push the changes to CHANGELOG.md, or just print them. Default is false (print only).</li> <li><code>extra_instructions</code>: Optional extra instructions to the tool. For example: \"focus on the changes in the file X. Ignore change in ...</li> </ul>"},{"location":"usage-guide/","title":"Usage guide","text":"<p>This page provides a detailed guide on how to use PR-Agent. It includes information on how to adjust PR-Agent configurations, define which tools will run automatically, manage mail notifications, and other advanced configurations.</p> <ul> <li>Introduction</li> <li>Configuration Options</li> <li>Usage and Automation<ul> <li>Local Repo (CLI)</li> <li>Online Usage</li> <li>GitHub App</li> <li>GitHub Action</li> <li>GitLab Webhook</li> <li>BitBucket App</li> <li>Azure DevOps Provider</li> </ul> </li> <li>Managing Mail Notifications</li> <li>Additional Configurations Walkthrough<ul> <li>Ignoring files from analysis</li> <li>Extra instructions</li> <li>Working with large PRs</li> <li>Changing a model</li> <li>Patch Extra Lines</li> <li>Editing the prompts</li> </ul> </li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/","title":"EXAMPLE BEST PRACTICE","text":""},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#recommend-python-best-practices","title":"Recommend Python Best Practices","text":"<p>This document outlines a series of recommended best practices for Python development. These guidelines aim to improve code quality, maintainability, and readability.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#imports","title":"Imports","text":"<p>Use  <code>import</code>  statements for packages and modules only, not for individual types, classes, or functions.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition","title":"Definition","text":"<p>Reusability mechanism for sharing code from one module to another.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision","title":"Decision","text":"<ul> <li>Use  <code>import x</code>  for importing packages and modules.</li> <li>Use  <code>from x import y</code>  where  <code>x</code>  is the package prefix and  <code>y</code>  is the module name with no prefix.</li> <li>Use  <code>from x import y as z</code>  in any of the following circumstances:<ul> <li>Two modules named  <code>y</code>  are to be imported.</li> <li><code>y</code>  conflicts with a top-level name defined in the current module.</li> <li><code>y</code>  conflicts with a common parameter name that is part of the public API (e.g.,  <code>features</code>).</li> <li><code>y</code>  is an inconveniently long name, or too generic in the context of your code</li> </ul> </li> <li>Use  <code>import y as z</code>  only when  <code>z</code>  is a standard abbreviation (e.g.,  <code>import numpy as np</code>).</li> </ul> <p>For example the module  <code>sound.effects.echo</code>  may be imported as follows:</p> <pre><code>from sound.effects import echo\n...\necho.EchoFilter(input, output, delay=0.7, atten=4)\n</code></pre> <p>Do not use relative names in imports. Even if the module is in the same package, use the full package name. This helps prevent unintentionally importing a package twice.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#exemptions","title":"Exemptions","text":"<p>Exemptions from this rule:</p> <ul> <li>Symbols from the following modules are used to support static analysis and type checking:<ul> <li><code>typing</code>  module</li> <li><code>collections.abc</code>  module</li> <li><code>typing_extensions</code>  module</li> </ul> </li> <li>Redirects from the  six.moves module.</li> </ul>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#packages","title":"Packages","text":"<p>Import each module using the full pathname location of the module.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_1","title":"Decision","text":"<p>All new code should import each module by its full package name.</p> <p>Imports should be as follows:</p> <pre><code>Yes:\n  # Reference absl.flags in code with the complete name (verbose).\n  import absl.flags\n  from doctor.who import jodie\n\n  _FOO = absl.flags.DEFINE_string(...)\n</code></pre> <pre><code>Yes:\n  # Reference flags in code with just the module name (common).\n  from absl import flags\n  from doctor.who import jodie\n\n  _FOO = flags.DEFINE_string(...)\n</code></pre> <p>(assume this file lives in  <code>doctor/who/</code>  where  <code>jodie.py</code>  also exists)</p> <pre><code>No:\n  # Unclear what module the author wanted and what will be imported.  The actual\n  # import behavior depends on external factors controlling sys.path.\n  # Which possible jodie module did the author intend to import?\n  import jodie\n</code></pre> <p>The directory the main binary is located in should not be assumed to be in  <code>sys.path</code>  despite that happening in some environments. This being the case, code should assume that  <code>import jodie</code>  refers to a third-party or top-level package named  <code>jodie</code>, not a local  <code>jodie.py</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-iterators-and-operators","title":"Default Iterators and Operators","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_1","title":"Definition","text":"<p>Container types, like dictionaries and lists, define default iterators and membership test operators (\u201cin\u201d and \u201cnot in\u201d).</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_2","title":"Decision","text":"<p>Use default iterators and operators for types that support them, like lists, dictionaries, and files. The built-in types define iterator methods, too. Prefer these methods to methods that return lists, except that you should not mutate a container while iterating over it.</p> <pre><code>Yes:  for key in adict: ...\n      if obj in alist: ...\n      for line in afile: ...\n      for k, v in adict.items(): ...\n</code></pre> <pre><code>No:   for key in adict.keys(): ...\n      for line in afile.readlines(): ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lambda-functions","title":"Lambda Functions","text":"<p>Okay for one-liners. Prefer generator expressions over  <code>map()</code>  or  <code>filter()</code>  with a  <code>lambda</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_3","title":"Decision","text":"<p>Lambdas are allowed. If the code inside the lambda function spans multiple lines or is longer than 60-80 chars, it might be better to define it as a regular  nested function.</p> <p>For common operations like multiplication, use the functions from the  <code>operator</code>  module instead of lambda functions. For example, prefer  <code>operator.mul</code>  to  <code>lambda x, y: x * y</code>.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#default-argument-values","title":"Default Argument Values","text":"<p>Okay in most cases.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#definition_2","title":"Definition","text":"<p>You can specify values for variables at the end of a function\u2019s parameter list, e.g.,  <code>def foo(a, b=0):</code>. If  <code>foo</code>  is called with only one argument,  <code>b</code>  is set to 0. If it is called with two arguments,  <code>b</code>  has the value of the second argument.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_4","title":"Decision","text":"<p>Okay to use with the following caveat:</p> <p>Do not use mutable objects as default values in the function or method definition.</p> <pre><code>Yes: def foo(a, b=None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence | None = None):\n         if b is None:\n             b = []\nYes: def foo(a, b: Sequence = ()):  # Empty tuple OK since tuples are immutable.\n         ...\n</code></pre> <pre><code>from absl import flags\n_FOO = flags.DEFINE_string(...)\n\nNo:  def foo(a, b=[]):\n         ...\nNo:  def foo(a, b=time.time()):  # Is `b` supposed to represent when this module was loaded?\n         ...\nNo:  def foo(a, b=_FOO.value):  # sys.argv has not yet been parsed...\n         ...\nNo:  def foo(a, b: Mapping = {}):  # Could still get passed to unchecked code.\n         ...\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#truefalse-evaluations","title":"True/False Evaluations","text":"<p>Use the \u201cimplicit\u201d false if possible, e.g.,  <code>if foo:</code>  rather than  <code>if foo != []:</code></p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#lexical-scoping","title":"Lexical Scoping","text":"<p>Okay to use.</p> <p>An example of the use of this feature is:</p> <pre><code>def get_adder(summand1: float) -&gt; Callable[[float], float]:\n    \"\"\"Returns a function that adds numbers to a given number.\"\"\"\n    def adder(summand2: float) -&gt; float:\n        return summand1 + summand2\n\n    return adder\n</code></pre>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#decision_5","title":"Decision","text":"<p>Okay to use.</p>"},{"location":"usage-guide/EXAMPLE_BEST_PRACTICE/#threading","title":"Threading","text":"<p>Do not rely on the atomicity of built-in types.</p> <p>While Python\u2019s built-in data types such as dictionaries appear to have atomic operations, there are corner cases where they aren\u2019t atomic (e.g. if  <code>__hash__</code>  or  <code>__eq__</code>  are implemented as Python methods) and their atomicity should not be relied upon. Neither should you rely on atomic variable assignment (since this in turn depends on dictionaries).</p> <p>Use the  <code>queue</code>  module\u2019s  <code>Queue</code>  data type as the preferred way to communicate data between threads. Otherwise, use the  <code>threading</code>  module and its locking primitives. Prefer condition variables and  <code>threading.Condition</code>  instead of using lower-level locks.</p>"},{"location":"usage-guide/additional_configurations/","title":"Additional Configurations","text":""},{"location":"usage-guide/additional_configurations/#ignoring-files-from-analysis","title":"Ignoring files from analysis","text":"<p>In some cases, you may want to exclude specific files or directories from the analysis performed by CodiumAI PR-Agent. This can be useful, for example, when you have files that are generated automatically or files that shouldn't be reviewed, like vendored code.</p> <p>You can ignore files or folders using the following methods:  - <code>IGNORE.GLOB</code>  - <code>IGNORE.REGEX</code></p> <p>which you can edit to ignore files or folders based on glob or regex patterns.</p>"},{"location":"usage-guide/additional_configurations/#example-usage","title":"Example usage","text":"<p>Let's look at an example where we want to ignore all files with <code>.py</code> extension from the analysis.</p> <p>To ignore Python files in a PR with online usage, comment on a PR: <code>/review --ignore.glob=\"['*.py']\"</code></p> <p>To ignore Python files in all PRs using <code>glob</code> pattern, set in a configuration file: <pre><code>[ignore]\nglob = ['*.py']\n</code></pre></p> <p>And to ignore Python files in all PRs using <code>regex</code> pattern, set in a configuration file: <pre><code>[regex]\nregex = ['.*\\.py$']\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#extra-instructions","title":"Extra instructions","text":"<p>All PR-Agent tools have a parameter called <code>extra_instructions</code>, that enables to add free-text extra instructions. Example usage: <pre><code>/update_changelog --pr_update_changelog.extra_instructions=\"Make sure to update also the version ...\"\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#working-with-large-prs","title":"Working with large PRs","text":"<p>The default mode of CodiumAI is to have a single call per tool, using GPT-4, which has a token limit of 8000 tokens. This mode provides a very good speed-quality-cost tradeoff, and can handle most PRs successfully. When the PR is above the token limit, it employs a PR Compression strategy.</p> <p>However, for very large PRs, or in case you want to emphasize quality over speed and cost, there are two possible solutions: 1) Use a model with larger context, like GPT-32K, or claude-100K. This solution will be applicable for all the tools. 2) For the <code>/improve</code> tool, there is an 'extended' mode (<code>/improve --extended</code>), which divides the PR to chunks, and processes each chunk separately. With this mode, regardless of the model, no compression will be done (but for large PRs, multiple model calls may occur)</p>"},{"location":"usage-guide/additional_configurations/#changing-a-model","title":"Changing a model","text":"<p>See here for the list of available models. To use a different model than the default (GPT-4), you need to edit configuration file. For models and environments not from OPENAI, you might need to provide additional keys and other parameters. See below for instructions.</p>"},{"location":"usage-guide/additional_configurations/#azure","title":"Azure","text":"<p>To use Azure, set in your <code>.secrets.toml</code> (working from CLI), or in the GitHub <code>Settings &gt; Secrets and variables</code> (working from GitHub App or GitHub Action): <pre><code>[openai]\nkey = \"\" # your azure api key\napi_type = \"azure\"\napi_version = '2023-05-15'  # Check Azure documentation for the current API version\napi_base = \"\"  # The base URL for your Azure OpenAI resource. e.g. \"https://&lt;your resource name&gt;.openai.azure.com\"\ndeployment_id = \"\"  # The deployment name you chose when you deployed the engine\n</code></pre></p> <p>and set in your configuration file: <pre><code>[config]\nmodel=\"\" # the OpenAI model you've deployed on Azure (e.g. gpt-3.5-turbo)\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#hugging-face","title":"Hugging Face","text":"<p>Local You can run Hugging Face models locally through either VLLM or Ollama</p> <p>E.g. to use a new Hugging Face model locally via Ollama, set: <pre><code>[__init__.py]\nMAX_TOKENS = {\n    \"model-name-on-ollama\": &lt;max_tokens&gt;\n}\ne.g.\nMAX_TOKENS={\n    ...,\n    \"ollama/llama2\": 4096\n}\n\n\n[config] # in configuration.toml\nmodel = \"ollama/llama2\"\nmodel_turbo = \"ollama/llama2\"\n\n[ollama] # in .secrets.toml\napi_base = ... # the base url for your Hugging Face inference endpoint\n# e.g. if running Ollama locally, you may use:\napi_base = \"http://localhost:11434/\"\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#inference-endpoints","title":"Inference Endpoints","text":"<p>To use a new model with Hugging Face Inference Endpoints, for example, set: <pre><code>[__init__.py]\nMAX_TOKENS = {\n    \"model-name-on-huggingface\": &lt;max_tokens&gt;\n}\ne.g.\nMAX_TOKENS={\n    ...,\n    \"meta-llama/Llama-2-7b-chat-hf\": 4096\n}\n[config] # in configuration.toml\nmodel = \"huggingface/meta-llama/Llama-2-7b-chat-hf\"\nmodel_turbo = \"huggingface/meta-llama/Llama-2-7b-chat-hf\"\n\n[huggingface] # in .secrets.toml\nkey = ... # your Hugging Face api key\napi_base = ... # the base url for your Hugging Face inference endpoint\n</code></pre> (you can obtain a Llama2 key from here)</p>"},{"location":"usage-guide/additional_configurations/#replicate","title":"Replicate","text":"<p>To use Llama2 model with Replicate, for example, set: <pre><code>[config] # in configuration.toml\nmodel = \"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"\nmodel_turbo = \"replicate/llama-2-70b-chat:2c1608e18606fad2812020dc541930f2d0495ce32eee50074220b87300bc16e1\"\n[replicate] # in .secrets.toml\nkey = ...\n</code></pre> (you can obtain a Llama2 key from here)</p> <p>Also, review the AiHandler file for instructions on how to set keys for other models.</p>"},{"location":"usage-guide/additional_configurations/#groq","title":"Groq","text":"<p>To use Llama3 model with Groq, for example, set: <pre><code>[config] # in configuration.toml\nmodel = \"llama3-70b-8192\"\nmodel_turbo = \"llama3-70b-8192\"\nfallback_models = [\"groq/llama3-70b-8192\"] \n[groq] # in .secrets.toml\nkey = ... # your Groq api key\n</code></pre> (you can obtain a Groq key from here)</p>"},{"location":"usage-guide/additional_configurations/#vertex-ai","title":"Vertex AI","text":"<p>To use Google's Vertex AI platform and its associated models (chat-bison/codechat-bison) set:</p> <pre><code>[config] # in configuration.toml\nmodel = \"vertex_ai/codechat-bison\"\nmodel_turbo = \"vertex_ai/codechat-bison\"\nfallback_models=\"vertex_ai/codechat-bison\"\n\n[vertexai] # in .secrets.toml\nvertex_project = \"my-google-cloud-project\"\nvertex_location = \"\"\n</code></pre> <p>Your application default credentials will be used for authentication so there is no need to set explicit credentials in most environments.</p> <p>If you do want to set explicit credentials then you can use the <code>GOOGLE_APPLICATION_CREDENTIALS</code> environment variable set to a path to a json credentials file.</p>"},{"location":"usage-guide/additional_configurations/#anthropic","title":"Anthropic","text":"<p>To use Anthropic models, set the relevant models in the configuration section of the configuration file: <pre><code>[config]\nmodel=\"anthropic/claude-3-opus-20240229\"\nmodel_turbo=\"anthropic/claude-3-opus-20240229\"\nfallback_models=[\"anthropic/claude-3-opus-20240229\"]\n</code></pre></p> <p>And also set the api key in the .secrets.toml file: <pre><code>[anthropic]\nKEY = \"...\"\n</code></pre></p>"},{"location":"usage-guide/additional_configurations/#amazon-bedrock","title":"Amazon Bedrock","text":"<p>To use Amazon Bedrock and its foundational models, add the below configuration:</p> <pre><code>[config] # in configuration.toml\nmodel=\"bedrock/anthropic.claude-3-sonnet-20240229-v1:0\"\nmodel_turbo=\"bedrock/anthropic.claude-3-sonnet-20240229-v1:0\"\nfallback_models=[\"bedrock/anthropic.claude-v2:1\"]\n\n[aws] # in .secrets.toml\nbedrock_region = \"us-east-1\"\n</code></pre> <p>Note that you have to add access to foundational models before using them. Please refer to this document for more details.</p> <p>If you are using the claude-3 model, please configure the following settings as there are parameters incompatible with claude-3. <pre><code>[litellm]\ndrop_params = true\n</code></pre></p> <p>AWS session is automatically authenticated from your environment, but you can also explicitly set <code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment variables.</p>"},{"location":"usage-guide/additional_configurations/#patch-extra-lines","title":"Patch Extra Lines","text":"<p>By default, around any change in your PR, git patch provides three lines of context above and below the change. <pre><code>@@ -12,5 +12,5 @@ def func1():\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file....\n-code line that was removed in the PR\n+new code line added in the PR\n code line that already existed in the file...\n code line that already existed in the file...\n code line that already existed in the file...\n</code></pre></p> <p>For the <code>review</code>, <code>describe</code>, <code>ask</code> and <code>add_docs</code> tools, if the token budget allows, PR-Agent tries to increase the number of lines of context, via the parameter: <pre><code>[config]\npatch_extra_lines=3\n</code></pre></p> <p>Increasing this number provides more context to the model, but will also increase the token budget. If the PR is too large (see PR Compression strategy), PR-Agent automatically sets this number to 0, using the original git patch.</p>"},{"location":"usage-guide/additional_configurations/#editing-the-prompts","title":"Editing the prompts","text":"<p>The prompts for the various PR-Agent tools are defined in the <code>pr_agent/settings</code> folder. In practice, the prompts are loaded and stored as a standard setting object. Hence, editing them is similar to editing any other configuration value - just place the relevant key in <code>.pr_agent.toml</code>file, and override the default value.</p> <p>For example, if you want to edit the prompts of the describe tool, you can add the following to your <code>.pr_agent.toml</code> file: <pre><code>[pr_description_prompt]\nsystem=\"\"\"\n...\n\"\"\"\nuser=\"\"\"\n...\n\"\"\"\n</code></pre> Note that the new prompt will need to generate an output compatible with the relevant post-process function.</p>"},{"location":"usage-guide/automations_and_usage/","title":"Usage and Automation","text":""},{"location":"usage-guide/automations_and_usage/#local-repo-cli","title":"Local repo (CLI)","text":"<p>When running from your locally cloned PR-Agent repo (CLI), your local configuration file will be used. Examples of invoking the different tools via the CLI:</p> <ul> <li>Review:       <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  review</code></li> <li>Describe:     <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  describe</code></li> <li>Improve:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  improve</code></li> <li>Ask:          <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  ask \"Write me a poem about this PR\"</code></li> <li>Reflect:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  reflect</code></li> <li>Update Changelog:      <code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  update_changelog</code></li> </ul> <p><code>&lt;pr_url&gt;</code> is the url of the relevant PR (for example: #50).</p> <p>Notes:</p> <p>(1) in addition to editing your local configuration file, you can also change any configuration value by adding it to the command line: <pre><code>python -m pr_agent.cli --pr_url=&lt;pr_url&gt;  /review --pr_reviewer.extra_instructions=\"focus on the file: ...\"\n</code></pre></p> <p>(2) You can print results locally, without publishing them, by setting in <code>configuration.toml</code>: <pre><code>[config]\npublish_output=false\nverbosity_level=2\n</code></pre> This is useful for debugging or experimenting with different tools.</p>"},{"location":"usage-guide/automations_and_usage/#online-usage","title":"Online usage","text":"<p>Online usage means invoking PR-Agent tools by comments on a PR. Commands for invoking the different tools via comments:</p> <ul> <li>Review:       <code>/review</code></li> <li>Describe:     <code>/describe</code></li> <li>Improve:      <code>/improve</code></li> <li>Ask:          <code>/ask \"...\"</code></li> <li>Reflect:      <code>/reflect</code></li> <li>Update Changelog:      <code>/update_changelog</code></li> </ul> <p>To edit a specific configuration value, just add <code>--config_path=&lt;value&gt;</code> to any command. For example, if you want to edit the <code>review</code> tool configurations, you can run: <pre><code>/review --pr_reviewer.extra_instructions=\"...\" --pr_reviewer.require_score_review=false\n</code></pre> Any configuration value in configuration file file can be similarly edited. Comment <code>/config</code> to see the list of available configurations.</p>"},{"location":"usage-guide/automations_and_usage/#github-app","title":"GitHub App","text":"<p>Configurations for PR-Agent Pro</p> <p>PR-Agent Pro for GitHub is an App, hosted by CodiumAI. So all the instructions below are relevant also for PR-Agent Pro users. Same goes for GitLab webhook and BitBucket App sections.</p>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-when-a-new-pr-is-opened","title":"GitHub app automatic tools when a new PR is opened","text":"<p>The github_app section defines GitHub app specific configurations.  </p> <p>The configuration parameter <code>pr_commands</code> defines the list of tools that will be run automatically when a new PR is opened. <pre><code>[github_app]\npr_commands = [\n    \"/describe --pr_description.final_update_message=false\",\n    \"/review --pr_reviewer.num_code_suggestions=0\",\n    \"/improve\",\n]\n</code></pre> This means that when a new PR is opened/reopened or marked as ready for review, PR-Agent will run the <code>describe</code>, <code>review</code> and <code>improve</code> tools. For the <code>review</code> tool, for example, the <code>num_code_suggestions</code> parameter will be set to 0.</p> <p>You can override the default tool parameters by using one the three options for a configuration file: wiki, local, or global.  For example, if your local <code>.pr_agent.toml</code> file contains: <pre><code>[pr_description]\ngenerate_ai_title = true\n</code></pre> Every time you run the <code>describe</code> tool, including automatic runs, the PR title will be generated by the AI.</p> <p>To cancel the automatic run of all the tools, set: <pre><code>[github_app]\npr_commands = []\n</code></pre></p> <p>You can also disable automatic runs for PRs with specific titles, by setting the <code>ignore_pr_titles</code> parameter with the relevant regex. For example: <pre><code>[github_app]\nignore_pr_title = [\"^[Auto]\", \".*ignore.*\"]\n</code></pre> will ignore PRs with titles that start with \"Auto\" or contain the word \"ignore\".</p>"},{"location":"usage-guide/automations_and_usage/#github-app-automatic-tools-for-push-actions-commits-to-an-open-pr","title":"GitHub app automatic tools for push actions (commits to an open PR)","text":"<p>In addition to running automatic tools when a PR is opened, the GitHub app can also respond to new code that is pushed to an open PR.</p> <p>The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the PR. <pre><code>[github_app]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review  --pr_reviewer.num_code_suggestions=0 --pr_reviewer.final_update_message=false\",\n]\n</code></pre> This means that when new code is pushed to the PR, the PR-Agent will run the <code>describe</code> and <code>review</code> tools, with the specified parameters.</p>"},{"location":"usage-guide/automations_and_usage/#github-action","title":"GitHub Action","text":"<p><code>GitHub Action</code> is a different way to trigger PR-Agent tools, and uses a different configuration mechanism than <code>GitHub App</code>. You can configure settings for <code>GitHub Action</code> by adding environment variables under the env section in <code>.github/workflows/pr_agent.yml</code> file.  Specifically, start by setting the following environment variables: <pre><code>      env:\n        OPENAI_KEY: ${{ secrets.OPENAI_KEY }} # Make sure to add your OpenAI key to your repo secrets\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Make sure to add your GitHub token to your repo secrets\n        github_action_config.auto_review: \"true\" # enable\\disable auto review\n        github_action_config.auto_describe: \"true\" # enable\\disable auto describe\n        github_action_config.auto_improve: \"true\" # enable\\disable auto improve\n</code></pre> <code>github_action_config.auto_review</code>, <code>github_action_config.auto_describe</code> and <code>github_action_config.auto_improve</code> are used to enable/disable automatic tools that run when a new PR is opened. If not set, the default configuration is for all three tools to run automatically when a new PR is opened.</p> <p><code>github_action_config.enable_output</code> are used to enable/disable github actions output parameter (default is <code>true</code>).  Review result is output as JSON to <code>steps.{step-id}.outputs.review</code> property. The JSON structure is equivalent to the yaml data structure defined in pr_reviewer_prompts.toml.</p> <p>Note that you can give additional config parameters by adding environment variables to <code>.github/workflows/pr_agent.yml</code>, or by using a <code>.pr_agent.toml</code> configuration file in the root of your repo</p> <p>For example, you can set an environment variable: <code>pr_description.publish_labels=false</code>, or add a <code>.pr_agent.toml</code> file with the following content: <pre><code>[pr_description]\npublish_labels = false\n</code></pre> to prevent PR-Agent from publishing labels when running the <code>describe</code> tool.</p>"},{"location":"usage-guide/automations_and_usage/#gitlab-webhook","title":"GitLab Webhook","text":"<p>After setting up a GitLab webhook, to control which commands will run automatically when a new MR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App: <pre><code>[gitlab]\npr_commands = [\n    \"/describe\",\n    \"/review --pr_reviewer.num_code_suggestions=0\",\n    \"/improve\",\n]\n</code></pre></p> <p>the GitLab webhook can also respond to new code that is pushed to an open MR. The configuration toggle <code>handle_push_trigger</code> can be used to enable this feature. The configuration parameter <code>push_commands</code> defines the list of tools that will be run automatically when new code is pushed to the MR. <pre><code>[gitlab]\nhandle_push_trigger = true\npush_commands = [\n    \"/describe\",\n    \"/review  --pr_reviewer.num_code_suggestions=0 --pr_reviewer.final_update_message=false\",\n]\n</code></pre></p> <p>Note that to use the 'handle_push_trigger' feature, you need to give the gitlab webhook also the \"Push events\" scope.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-app","title":"BitBucket App","text":"<p>Similar to GitHub app, when running PR-Agent from BitBucket App, the default configuration file from a pre-built docker will be initially loaded.</p> <p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's main branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if your local <code>.pr_agent.toml</code> file contains: <pre><code>[pr_reviewer]\ninline_code_comments = true\n</code></pre></p> <p>Each time you invoke a <code>/review</code> tool, it will use inline code comments.</p>"},{"location":"usage-guide/automations_and_usage/#bitbucket-self-hosted-app-automatic-tools","title":"BitBucket Self-Hosted App automatic tools","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file: Specifically, set the following values:</p> <p><pre><code>[bitbucket_app]\npr_commands = [\n    \"/review --pr_reviewer.num_code_suggestions=0\",\n    \"/improve --pr_code_suggestions.commitable_code_suggestions=true --pr_code_suggestions.suggestions_score_threshold=7\",\n]\n</code></pre> Note that we set specifically for bitbucket, we recommend using: <code>--pr_code_suggestions.suggestions_score_threshold=7</code> and that is the default value we set for bitbucket. Since this platform only supports inline code suggestions, we want to limit the number of suggestions, and only present a limited number.</p>"},{"location":"usage-guide/automations_and_usage/#azure-devops-provider","title":"Azure DevOps provider","text":"<p>To use Azure DevOps provider use the following settings in configuration.toml: <pre><code>[config]\ngit_provider=\"azure\"\n</code></pre></p> <p>Azure DevOps provider supports PAT token or DefaultAzureCredential authentication. PAT is faster to create, but has build in expiration date, and will use the user identity for API calls.  Using DefaultAzureCredential you can use managed identity or Service principle, which are more secure and will create separate ADO user identity (via AAD) to the agent.</p> <p>If PAT was chosen, you can assign the value in .secrets.toml.  If DefaultAzureCredential was chosen, you can assigned the additional env vars like AZURE_CLIENT_SECRET directly,  or use managed identity/az cli (for local development) without any additional configuration. in any case, 'org' value must be assigned in .secrets.toml: <pre><code>[azure_devops]\norg = \"https://dev.azure.com/YOUR_ORGANIZATION/\"\n# pat = \"YOUR_PAT_TOKEN\" needed only if using PAT for authentication\n</code></pre></p>"},{"location":"usage-guide/automations_and_usage/#azure-devops-webhook","title":"Azure DevOps Webhook","text":"<p>To control which commands will run automatically when a new PR is opened, you can set the <code>pr_commands</code> parameter in the configuration file, similar to the GitHub App: <pre><code>[azure_devops_server]\npr_commands = [\n    \"/describe\",\n    \"/review --pr_reviewer.num_code_suggestions=0\",\n    \"/improve\",\n]\n</code></pre></p>"},{"location":"usage-guide/configuration_options/","title":"Configuration Options","text":"<p>The different tools and sub-tools used by CodiumAI PR-Agent are adjustable via the configuration file.</p> <p>In addition to general configuration options, each tool has its own configurations. For example, the <code>review</code> tool will use parameters from the pr_reviewer section in the configuration file. See the Tools Guide for a detailed description of the different tools and their configurations.</p> <p>There are three ways to set persistent configurations:</p> <ol> <li>Wiki configuration page \ud83d\udc8e</li> <li>Local configuration file</li> <li>Global configuration file \ud83d\udc8e</li> </ol> <p>In terms of precedence, wiki configurations will override local configurations, and local configurations will override global configurations.</p> <p>Tip1: edit only what you need</p> <p>Your configuration file should be minimal, and edit only the relevant values. Don't copy the entire configuration options, since it can lead to legacy problems when something changes.</p> <p>Tip2: show relevant configurations</p> <p>If you set <code>config.output_relevant_configurations=true</code>, each tool will also output in a collapsible section its relevant configurations. This can be useful for debugging, or getting to know the configurations better.</p>"},{"location":"usage-guide/configuration_options/#wiki-configuration-file","title":"Wiki configuration file \ud83d\udc8e","text":"<p>For GitHub and GitLab, with PR-Agent-Pro you can set configurations by creating a page called <code>.pr_agent.toml</code> in the wiki of the repo.  The advantage of this method is that it allows to set configurations without needing to commit new content to the repo - just edit the wiki page and save.</p> <p></p> <p>Click here to see a short instructional video. We recommend surrounding the configuration content with triple-quotes, to allow better presentation when displayed in the wiki as markdown. An example content:</p> <pre><code>[pr_description]\ngenerate_ai_title=true\n</code></pre> <p>PR-Agent will know to remove the triple-quotes when reading the configuration content.</p>"},{"location":"usage-guide/configuration_options/#local-configuration-file","title":"Local configuration file","text":"<p>By uploading a local <code>.pr_agent.toml</code> file to the root of the repo's main branch, you can edit and customize any configuration parameter. Note that you need to upload <code>.pr_agent.toml</code> prior to creating a PR, in order for the configuration to take effect.</p> <p>For example, if you set in <code>.pr_agent.toml</code>:</p> <pre><code>[pr_reviewer]\nextra_instructions=\"\"\"\\\n- instruction a\n- instruction b\n...\n\"\"\"\n</code></pre> <p>Then you can give a list of extra instructions to the <code>review</code> tool.</p>"},{"location":"usage-guide/configuration_options/#global-configuration-file","title":"Global configuration file \ud83d\udc8e","text":"<p>If you create a repo called <code>pr-agent-settings</code> in your organization, it's configuration file <code>.pr_agent.toml</code> will be used as a global configuration file for any other repo that belongs to the same organization. Parameters from a local <code>.pr_agent.toml</code> file, in a specific repo, will override the global configuration parameters.</p> <p>For example, in the GitHub organization <code>Codium-ai</code>:</p> <ul> <li> <p>The file <code>https://github.com/Codium-ai/pr-agent-settings/.pr_agent.toml</code>  serves as a global configuration file for all the repos in the GitHub organization <code>Codium-ai</code>.</p> </li> <li> <p>The repo <code>https://github.com/Codium-ai/pr-agent</code>, for example, inherits the global configuration file from <code>pr-agent-settings</code>.</p> </li> </ul>"},{"location":"usage-guide/introduction/","title":"Introduction","text":"<p>After installation, there are three basic ways to invoke CodiumAI PR-Agent:</p> <ol> <li>Locally running a CLI command</li> <li>Online usage - by commenting on a PR</li> <li>Enabling PR-Agent tools to run automatically when a new PR is opened</li> </ol> <p>Specifically, CLI commands can be issued by invoking a pre-built docker image, or by invoking a locally cloned repo. For online usage, you will need to setup either a GitHub App, or a GitHub Action. GitHub App and GitHub Action also enable to run PR-Agent specific tool automatically when a new PR is opened.</p> <p>git provider: The git_provider field in the configuration file determines the GIT provider that will be used by PR-Agent. Currently, the following providers are supported: <code>\"github\", \"gitlab\", \"bitbucket\", \"azure\", \"codecommit\", \"local\", \"gerrit\"</code></p>"},{"location":"usage-guide/mail_notifications/","title":"Managing Mail Notifications","text":"<p>Unfortunately, it is not possible in GitHub to disable mail notifications from a specific user. If you are subscribed to notifications for a repo with PR-Agent, we recommend turning off notifications for PR comments, to avoid lengthy emails:</p> <p></p> <p>As an alternative, you can filter in your mail provider the notifications specifically from the PR-Agent bot, see how.</p> <p></p> <p>Another option to reduce the mail overload, yet still receive notifications on PR-Agent tools, is to disable the help collapsible section in PR-Agent bot comments.  This can done by setting <code>enable_help_text=false</code> for the relevant tool in the configuration file. For example, to disable the help text for the <code>pr_reviewer</code> tool, set: <pre><code>[pr_reviewer]\nenable_help_text = false\n</code></pre></p>"}]}